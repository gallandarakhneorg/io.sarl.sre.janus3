/* 
 * $Id$
 * 
 * SARL is an general-purpose agent programming language.
 * More details on http://www.sarl.io
 * 
 * Copyright (C) 2014-2017 the original authors or authors.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.janusproject.sre

import com.google.common.base.Strings
import com.google.inject.Guice
import com.google.inject.ImplementedBy
import com.google.inject.Module
import io.janusproject.sre.services.executor.EarlyExitException
import io.janusproject.sre.services.executor.ExecutorService
import io.janusproject.sre.services.logging.LoggerCreator
import io.janusproject.sre.services.logging.LoggingService
import io.sarl.bootstrap.SRE
import io.sarl.bootstrap.SREBootstrap
import io.sarl.lang.SARLVersion
import io.sarl.lang.core.Agent
import io.sarl.lang.core.AgentContext
import java.io.File
import java.io.PrintStream
import java.io.PrintWriter
import java.lang.reflect.Method
import java.net.URL
import java.net.URLClassLoader
import java.text.MessageFormat
import java.util.Arrays
import java.util.Properties
import java.util.UUID
import java.util.logging.Logger
import java.util.regex.Pattern
import org.apache.commons.cli.DefaultParser
import org.apache.commons.cli.HelpFormatter
import org.apache.commons.cli.Option
import org.apache.commons.cli.Options
import org.arakhne.afc.vmutil.FileSystem

import static io.sarl.bootstrap.SRE.*

/** 
 * This is the class that permits to boot the Janus platform.
 * 
 * <p>This class provides the "main" function for the platform. The list of the parameters is composed of a list of options, the
 * classname of an agent to launch, and the parameters to pass to the launched agent.
 * 
 * <p>The supported options may be obtain by passing no parameter, or the option <code>-h</code>.
 * 
 * <p>Example of Janus launching with Maven:
 * <pre>
 * <code>mvn exec:java
 * -Dexec.mainClass="io.janusproject.Boot"
 * -Dexec.args="my.Agent"</code>
 * </pre>
 * 
 * <p>Example of Janus launching from the CLI (only with the Jar file that is containing all the jar dependencies):
 * <pre>
 * <code>java -jar janus-with-dependencies.jar my.Agent</code>
 * </pre>
 * 
 * @author $Author: srodriguez$
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
class JanusBooter implements Booter {

	/** Short command-line option for "embedded".
	 */
	public static val CLI_OPTION_EMBEDDED_SHORT = "e"
	/** Long command-line option for "embedded".
	 */
	public static val CLI_OPTION_EMBEDDED_LONG = "embedded"
	/** Short command-line option for "boot agent id".
	 */
	public static val CLI_OPTION_BOOTID_SHORT = "B"
	/** Long command-line option for "boot agent id".
	 */
	public static val CLI_OPTION_BOOTID_LONG = "bootid"
	/** Short command-line option for "random id".
	 */
	public static val CLI_OPTION_RANDOMID_SHORT = "R"
	/** Long command-line option for "random id".
	 */
	public static val CLI_OPTION_RANDOMID_LONG = "randomid"
	/** Short command-line option for "Janus world id".
	 */
	public static val CLI_OPTION_WORLDID_SHORT = "W"
	/** Long command-line option for "Janus world id".
	 */
	public static val CLI_OPTION_WORLDID_LONG = "worldid"
	/** Short command-line option for "file".
	 */
	public static val CLI_OPTION_FILE_SHORT = "f"
	/** Long command-line option for "file".
	 */
	public static val CLI_OPTION_FILE_LONG = "file"
	/** Short command-line option for "help".
	 */
	public static val CLI_OPTION_HELP_SHORT = "h"
	/** Long command-line option for "help".
	 */
	public static val CLI_OPTION_HELP_LONG = "help"
	/** Long command-line option for "nologo".
	 */
	public static val CLI_OPTION_NOLOGO_LONG = "nologo"
	/** Short command-line option for "offline".
	 */
	public static val CLI_OPTION_OFFLINE_SHORT = "o"
	/** Long command-line option for "offline".
	 */
	public static val CLI_OPTION_OFFLINE_LONG = "offline"
	/** Short command-line option for "be quiet".
	 */
	public static val CLI_OPTION_QUIET_SHORT = "q"
	/** Long command-line option for "be quiet".
	 */
	public static val CLI_OPTION_QUIET_LONG = "quiet"
	/** Short command-line option for "be more verbose".
	 */
	public static val CLI_OPTION_VERBOSE_SHORT = "v"
	/** Long command-line option for "be more verbose".
	 */
	public static val CLI_OPTION_VERBOSE_LONG = "verbose"
	/** Long command-line option for "display the version".
	 */
	public static val CLI_OPTION_VERSION = "version"
	/** Short command-line option for "change log level".
	 */
	public static val CLI_OPTION_LOG_SHORT = "l"
	/** Long command-line option for "change log level".
	 */
	public static val CLI_OPTION_LOG_LONG = "log"
	/** Short command-line option for "env. variable definition".
	 */
	public static val CLI_OPTION_DEFINE_SHORT = "D"
	/** Long command-line option for "env. variable definition".
	 */
	public static val CLI_OPTION_DEFINE_LONG = "define"
	/** Short command-line option for "show defaults".
	 */
	public static val CLI_OPTION_SHOWDEFAULTS_SHORT = "s"
	/** Long command-line option for "show defaults".
	 */
	public static val CLI_OPTION_SHOWDEFAULTS_LONG = "showdefaults"
	/** Short command-line option for "show the classpath".
	 */
	public static val CLI_OPTION_SHOWCLASSPATH = "showclasspath"
	/** Short command-line option for "show CLI arguments".
	 */
	public static val CLI_OPTION_SHOWCLIARGUMENTS_LONG = "cli"
	/** Short command-line option for "classpath".
	 */
	public static val CLI_OPTION_CLASSPATH_SHORT = "cp"
	/** Long command-line option for "classpath".
	 */
	public static val CLI_OPTION_CLASSPATH_LONG = "classpath"

	static val ERROR_EXIT_CODE = 255

	var applicationExiter : Exiter
	
	var bootConsoleLogger : PrintStream

	var bootAgentId : UUID

	volatile var kernel : Kernel

	val loggerCreator = new LoggerCreator
	
	override parseCommandLine(args : String[]) : String[] {
		val parser = new DefaultParser
		try {
			val cmd = parser.parse(this.options, args, false)

			var noLogo = false
			var embedded = false
			var verbose = LoggerCreator::toInt(JanusConfig::VERBOSE_LEVEL_VALUE)
			val optIterator = cmd.iterator
			while (optIterator.hasNext) {
				var opt = optIterator.next
				var optName = opt.longOpt
				if (optName.nullOrEmpty) {
					optName = opt.opt
				}
				switch (optName) {
				case CLI_OPTION_HELP_LONG: {
					showHelp
					return null
				}
				case CLI_OPTION_VERSION: {
					showVersion
					return null
				}
				case CLI_OPTION_SHOWDEFAULTS_LONG: {
					showDefaults
					return null
				}
				case CLI_OPTION_SHOWCLASSPATH: {
					showClasspath
					return null
				}
				case CLI_OPTION_SHOWCLIARGUMENTS_LONG: {
					args.showCommandLineArguments
					return null;
				}
				case CLI_OPTION_FILE_LONG: {
					val rawFilename = opt.value
					if (rawFilename.nullOrEmpty) {
						showHelp
						return null
					}
					val file = new File(rawFilename)
					if (!file.canRead) {
						showError(MessageFormat::format(Messages::Boot_0, rawFilename), null);
						return null
					}
					JanusConfig::setPropertiesFrom(file)
				}
				case CLI_OPTION_CLASSPATH_LONG: {
					opt.value.addToSystemClasspath
				}
				case CLI_OPTION_OFFLINE_LONG: {
					setOffline(true)
				}
				case CLI_OPTION_RANDOMID_LONG: {
					setRandomContextUUID
				}
				case CLI_OPTION_BOOTID_LONG: {
					setBootAgentTypeContextUUID
				}
				case CLI_OPTION_WORLDID_LONG: {
					setDefaultContextUUID
				}
				case CLI_OPTION_DEFINE_LONG: {
					val name = opt.getValue(0)
					if (!name.nullOrEmpty) {
						JanusConfig::setProperty(name, Strings::emptyToNull(opt.getValue(1)))
					}
				}
				case CLI_OPTION_LOG_LONG: {
					verbose = Math::max(LoggerCreator::toInt(opt.value), 0)
				}
				case CLI_OPTION_QUIET_LONG: {
					if (verbose > 0) {
						verbose--
					}
				}
				case CLI_OPTION_VERBOSE_LONG: {
					verbose++
				}
				case CLI_OPTION_NOLOGO_LONG: {
					noLogo = true
				}
				case CLI_OPTION_EMBEDDED_LONG: {
					embedded = true;
				}
				}
			}

			// Show the help when there is no argument.
			if (cmd.args.length == 0) {
				showHelp
				return null
			}

			// Change the verbosity
			this.verboseLevel = verbose
			// Do nothing at exit
			if (embedded) {
				this.exiter = [ ExecutorService::neverReturn ]
			}
			// Show the Janus logo?
			if (noLogo || verbose == 0) {
					JanusConfig::setProperty(JanusConfig::JANUS_LOGO_SHOW_NAME, Boolean::FALSE.toString)
			}
			return cmd.args
		} catch (e : Throwable) {
			showError(e.localizedMessage, e)
			// Event if showError never returns, add the return statement for
			// avoiding compilation error.
			return null
		}
	}

	override addToSystemClasspath(entries : String) {
		if (!entries.nullOrEmpty) {
			val individualEntries = entries.split(Pattern::quote(File::pathSeparator))
			val sysloader = ClassLoader::getSystemClassLoader
			if (sysloader instanceof URLClassLoader) {
				var method : Method
				try {
					method = typeof(URLClassLoader).getDeclaredMethod("addURL", typeof(URL))
					method.accessible = true
				} catch (t : Throwable ) {
					showError(t.localizedMessage, t)
					return
				}
				for (entry : individualEntries) {
					if (!entry.nullOrEmpty) {
						val url = FileSystem::convertStringToURL(entry, false)
						if (url !== null) {
							try {
								method.invoke(sysloader, url)
							} catch (t : Throwable) {
								showError(t.localizedMessage, t)
							}
						}
					}
				}
			}
		}
	}

	private def loadAgentClass(fullyQualifiedName : String) : Class<? extends Agent> {
		var type : Class<?> 
		try {
			type = Class::forName(fullyQualifiedName)
		} catch (e : Exception) {
			showError(MessageFormat::format(
					Messages::Boot_1,
					fullyQualifiedName, System::getProperty("java.class.path")), //$NON-NLS-1$
					e);
			// Event if showError never returns, add the return statement for
			// avoiding compilation error.
			return null
		}
		// The following test is needed because the
		// cast to Class<? extends Agent> is not checking
		// the Agent type (it is a generic type, not
		// tested at runtime).
		if (typeof(Agent).isAssignableFrom(type)) {
			return type.asSubclass(typeof(Agent))
		}

		showError(MessageFormat::format(Messages::Boot_2, fullyQualifiedName), null);
		// Event if showError never returns, add the return statement for
		// avoiding compilation error.
		return null
	}

	@SuppressWarnings("discouraged_reference")
	override getConsoleLogger : PrintStream {
		this.bootConsoleLogger ?: System::out
	}

	override setConsoleLogger(stream : PrintStream) {
		this.bootConsoleLogger = stream
	}

	protected def getLogger : Logger {
		this.loggerCreator.createConsoleLogger(this.class.name, this.consoleLogger)
	}
	
	override getOptions : Options {
		var options = new Options

		options.addOption(CLI_OPTION_CLASSPATH_SHORT, CLI_OPTION_CLASSPATH_LONG, true,
				Messages::Boot_24)

		options.addOption(CLI_OPTION_EMBEDDED_SHORT, CLI_OPTION_EMBEDDED_LONG, false,
				Messages::Boot_5)

		options.addOption(CLI_OPTION_BOOTID_SHORT, CLI_OPTION_BOOTID_LONG, false,
				MessageFormat::format(Messages::Boot_6,
						JanusConfig::BOOT_DEFAULT_CONTEXT_ID_NAME, JanusConfig::RANDOM_DEFAULT_CONTEXT_ID_NAME))

		options.addOption(CLI_OPTION_FILE_SHORT, CLI_OPTION_FILE_LONG, true,
				Messages::Boot_7)

		options.addOption(CLI_OPTION_HELP_SHORT, CLI_OPTION_HELP_LONG, false,
				Messages::Boot_8)

		options.addOption(null, CLI_OPTION_NOLOGO_LONG, false,
				Messages::Boot_9)

		options.addOption(CLI_OPTION_OFFLINE_SHORT, CLI_OPTION_OFFLINE_LONG, false,
				MessageFormat::format(Messages::Boot_10, JanusConfig::OFFLINE))

		options.addOption(CLI_OPTION_QUIET_SHORT, CLI_OPTION_QUIET_LONG, false,
				Messages::Boot_11)

		options.addOption(CLI_OPTION_RANDOMID_SHORT, CLI_OPTION_RANDOMID_LONG, false,
				MessageFormat::format(Messages::Boot_12,
						JanusConfig::BOOT_DEFAULT_CONTEXT_ID_NAME, JanusConfig::RANDOM_DEFAULT_CONTEXT_ID_NAME))

		options.addOption(CLI_OPTION_SHOWDEFAULTS_SHORT, CLI_OPTION_SHOWDEFAULTS_LONG, false,
				Messages::Boot_13)

		options.addOption(CLI_OPTION_SHOWCLASSPATH, false,
				Messages::Boot_23)

		options.addOption(null, CLI_OPTION_SHOWCLIARGUMENTS_LONG, false,
				Messages::Boot_14)

		options.addOption(CLI_OPTION_VERBOSE_SHORT, CLI_OPTION_VERBOSE_LONG, false,
				Messages::Boot_15)

		options.addOption(CLI_OPTION_VERSION, false,
				Messages::Boot_25)

		options.addOption(CLI_OPTION_WORLDID_SHORT, CLI_OPTION_WORLDID_LONG, false,
				MessageFormat::format(Messages::Boot_16,
						JanusConfig::BOOT_DEFAULT_CONTEXT_ID_NAME, JanusConfig::RANDOM_DEFAULT_CONTEXT_ID_NAME))
						
		val b = new StringBuilder
		var level = 0
		for (logLevel : LoggerCreator::levelStrings) {
			if (b.length() > 0) {
				b.append(", ")
			}
			b.append(logLevel)
			b.append(" (")
			b.append(level)
			b.append(")")
			level++
		}
		var opt = new Option(CLI_OPTION_LOG_SHORT, CLI_OPTION_LOG_LONG, true,
				MessageFormat::format(Messages::Boot_17, JanusConfig::VERBOSE_LEVEL_VALUE, b))
		opt.args = 1
		options.addOption(opt)
		opt = new Option(CLI_OPTION_DEFINE_SHORT, CLI_OPTION_DEFINE_LONG, true, Messages::Boot_18)
		opt.args = 2
		opt.valueSeparator = '='
		opt.argName = Messages::Boot_19
		options.addOption(opt)
		return options
	}

	/**
	 * Show an error message, and exit.
	 *
	 * <p>This function never returns.
	 *
	 * @param message the description of the error.
	 * @param exception the cause of the error.
	 */
	def showError(message : String, exception : Throwable) {
		val logger = new PrintWriter(this.consoleLogger)
		try {
			if (!message.isNullOrEmpty) {
				logger.println(message)
			} else if (exception !== null) {
				exception.printStackTrace(logger)
			}
			logger.println
			logger.flush
			logger.showHelp
		} finally {
			logger.close
		}
	}

	/** 
	 * Show the help message on the standard console. This function never returns.
	 */
	override showHelp(logger : PrintWriter = null) : void {
		var output = logger ?: new PrintWriter(this.consoleLogger)
		try {
			val formatter = new HelpFormatter
			formatter.printHelp(output, HelpFormatter::DEFAULT_WIDTH,
					this.programName + " " //$NON-NLS-1$
					+ Messages::Boot_20,
					"", //$NON-NLS-1$
			this.options, HelpFormatter::DEFAULT_LEFT_PAD, HelpFormatter::DEFAULT_DESC_PAD, "")
			output.flush
		} finally {
			output.close
		}
		getExiter.exit
	}

	override getProgramName : String {
		var programName = JanusConfig::getSystemProperty(JanusConfig::JANUS_PROGRAM_NAME, null)
		if (programName.nullOrEmpty) {
			programName = JanusConfig::JANUS_PROGRAM_NAME_VALUE
		}
		return programName
	}

	override showDefaults {
		val defaultValues = new Properties
		JanusConfig::getDefaultValues(defaultValues)
		val os = this.consoleLogger
		try {
			defaultValues.storeToXML(os, null)
			os.flush
		} catch (e : Throwable) {
			e.printStackTrace(os)
		} finally {
			os.close
		}
		getExiter.exit
	}

	override showClasspath {
		val cp = System::getProperty("java.class.path")
		if (!cp.nullOrEmpty) {
			val ps = this.consoleLogger
			try {
				for (entry : cp.split(Pattern::quote(File::pathSeparator))) {
					ps.println(entry)
				}
				ps.flush
			} finally {
				ps.close
			}
		}
		getExiter.exit
	}

	override showVersion {
		val logger = new PrintWriter(this.consoleLogger)
		try {
			logger.println(MessageFormat::format(Messages::Boot_26, JanusVersion::JANUS_RELEASE_VERSION))
			logger.println(MessageFormat::format(Messages::Boot_27, SARLVersion::SPECIFICATION_RELEASE_VERSION_STRING))
			logger.flush();
		} finally {
			logger.close
		}
		getExiter.exit
	}

	/**
	 * Show the command line arguments. This function never returns.
	 *
	 * @param args the command line arguments.
	 */
	def showCommandLineArguments(args : String[]) {
		val os = this.consoleLogger
		try {
			for (var i = 0; i < args.length; i++) {
				os.println(i + ": " + args.get(i))
			}
			os.flush
		} catch (e : Throwable) {
			e.printStackTrace(os)
		} finally {
			os.close
		}
		getExiter.exit
	}

	override showJanusLogo {
		this.consoleLogger.println(Messages::Boot_21)
	}

	override setOffline(isOffline : boolean) {
		System::setProperty(JanusConfig::OFFLINE, Boolean::toString(isOffline))
	}

	override setRandomContextUUID {
		System::setProperty(JanusConfig::BOOT_DEFAULT_CONTEXT_ID_NAME, Boolean::FALSE.toString)
		System::setProperty(JanusConfig::RANDOM_DEFAULT_CONTEXT_ID_NAME, Boolean::TRUE.toString)
	}

	override setBootAgentTypeContextUUID {
		System::setProperty(JanusConfig::BOOT_DEFAULT_CONTEXT_ID_NAME, Boolean::TRUE.toString)
		System::setProperty(JanusConfig::RANDOM_DEFAULT_CONTEXT_ID_NAME, Boolean::FALSE.toString)
	}

	override setDefaultContextUUID {
		System::setProperty(JanusConfig::BOOT_DEFAULT_CONTEXT_ID_NAME, Boolean::FALSE.toString)
		System::setProperty(JanusConfig::RANDOM_DEFAULT_CONTEXT_ID_NAME, Boolean::FALSE.toString)
	}

	override setVerboseLevel(level : int) {
		System::setProperty(JanusConfig::VERBOSE_LEVEL_NAME, Integer::toString(level))
	}

	override getBootAgentIdentifier : UUID {
		var aid = this.bootAgentId
		if (aid === null) {
			val id = JanusConfig::getSystemProperty(JanusConfig::BOOT_AGENT_ID)
			if (!id.nullOrEmpty) {
				try {
					aid = UUID::fromString(id)
				} catch (exception : Throwable) {
					//
				}
			}
			this.bootAgentId = aid
		}
		return aid
	}

	def prepareJanusStart(agentType : Class<? extends Agent>) {
		// Set the boot agent class name
		System::setProperty(JanusConfig::BOOT_AGENT, agentType.name)
	}

	override startJanus(agentCls : Class<? extends Agent>, params : Object*) : Kernel {
		startJanusWithModuleType(null, agentCls, params)
	}

	override startJanusWithModuleType(platformModule : Class<? extends Module>, agentCls : Class<? extends Agent>,
		params : Object*) : Kernel {
		var startupModule = platformModule
		if (startupModule === null) {
			startupModule = JanusConfig::getSystemPropertyAsClass(typeof(Module), JanusConfig::INJECTION_MODULE_NAME,
					JanusConfig::INJECTION_MODULE_NAME_VALUE)
		}
		assert startupModule !== null, "No platform injection module"
		startJanusWithModule(startupModule.newInstance, agentCls, params)
	}

	override startJanusWithModule(startupModule : Module, agentCls : Class<? extends Agent>,
		params : Object*) : Kernel {
		// Prepare start
		prepareJanusStart(agentCls)
		// Get the start-up injection module
		startupModule.startWithoutAgent
		var logger = this.kernel.getLogger
		if (logger === null) {
			logger = getLogger
		}
		// TODO : Remove the message below
		logger.warning("EXPERIMENTAL VERSION")
		logger.info(MessageFormat::format(Messages::Boot_22, agentCls.name))
		val id = this.kernel.spawn(agentCls, params)
		this.bootAgentId = id
		if (id !== null) {
			System::setProperty(JanusConfig::BOOT_AGENT_ID, id.toString)
		} else {
			System::clearProperty(JanusConfig::BOOT_AGENT_ID)
		}
		return this.kernel
	}

	/** Start the Janus kernel without agent.
	 *
	 * @param the injection module.
	 * @return the kernel.
	 */
	def startWithoutAgent(startupModule : Module) : Kernel {
		assert startupModule !== null, "No platform injection module"
		val injector = Guice::createInjector(startupModule)
		this.kernel = injector.getInstance(typeof(Kernel))
		// Force the bootstrap to be this object
		SRE::bootstrap = this
		return this.kernel
	}

	override startWithoutAgent : AgentContext {
		var module = JanusConfig::getSystemPropertyAsClass(typeof(Module),
			JanusConfig::INJECTION_MODULE_NAME, JanusConfig::INJECTION_MODULE_NAME_VALUE)
		var kern = module.newInstance.startWithoutAgent
		return kern.rootContext
	}

	override startAgent(agentCls : Class<? extends Agent>, params : Object*) : UUID {
		var kern = this.kernel
		if (kern === null) {
			agentCls.startJanus(params)
			return this.bootAgentIdentifier
		}
		return kern.spawn(agentCls, params);
	}

	override startAgent(nbAgents : int, agentCls : Class<? extends Agent>, params : Object*) : Iterable<UUID> {
		var kern = this.kernel
		if (kern === null) {
			var kernel = startJanus(agentCls, params)
			var spawnedAgents = newArrayList
			spawnedAgents += this.bootAgentIdentifier
			if (nbAgents > 1) {
				spawnedAgents += kernel.spawn(nbAgents - 1, agentCls, params)
			}
			return spawnedAgents
		}
		return kern.spawn(nbAgents, agentCls, params)
	}

	
	@SuppressWarnings("discouraged_reference")
	override getExiter : Exiter {
		this.applicationExiter ?: [ System::exit(ERROR_EXIT_CODE) ]
	}

	override setExiter(exiter : Exiter) {
		this.applicationExiter = exiter
	}

	override runStandardBootProcess(args : String*) {
		try {
			var freeArgs = args.parseCommandLine
			if (JanusConfig::getSystemPropertyAsBoolean(JanusConfig::JANUS_LOGO_SHOW_NAME,
				JanusConfig::JANUS_LOGO_SHOW.booleanValue)) {
				showJanusLogo
			}

			if (freeArgs.length === 0) {
				showError(Messages::Boot_3, null)
				// Event if showError never returns, add the return statement for
				// avoiding compilation error.
				return
			}

			val agentToLaunch = freeArgs.get(0).toString
			freeArgs = Arrays::copyOfRange(freeArgs, 1, freeArgs.length, typeof(String[]))

			// Load the agent class
			val ^agent = agentToLaunch.loadAgentClass

			assert ^agent !== null
			startJanus(^agent, freeArgs)
		} catch (exception : EarlyExitException) {
			exception.runPostTreatment(this.logger)
		} catch (e : Throwable) {
			showError(MessageFormat::format(Messages::Boot_4, e.localizedMessage), e)
			// Even if showError never returns, add the return statement for
			// avoiding compilation error.
		}
	}

}

/** 
 * This is the interface that permits to boot the Janus platform.
 * 
 * <p>This class provides the "main" function for the platform. The list of the parameters is composed of a list of options, the
 * classname of an agent to launch, and the parameters to pass to the launched agent.
 * 
 * <p>The supported options may be obtain by passing no parameter, or the option <code>-h</code>.
 * 
 * <p>Example of Janus launching with Maven:
 * <pre>
 * <code>mvn exec:java
 * -Dexec.mainClass="io.janusproject.Boot"
 * -Dexec.args="my.Agent"</code>
 * </pre>
 * 
 * <p>Example of Janus launching from the CLI (only with the Jar file that is containing all the jar dependencies):
 * <pre>
 * <code>java -jar janus-with-dependencies.jar my.Agent</code>
 * </pre>
 * 
 * @author $Author: srodriguez$
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
@ImplementedBy(JanusBooter)
interface Booter extends SREBootstrap {

	/** 
	 * Run the standard boot process.
	 * 
	 * @param args command line arguments
	 * @see #startJanus(Class, Object...)
	 */
	def runStandardBootProcess(args : String*)

	/** 
	 * Parse the command line.
	 * 
	 * @param args the CLI arguments given to the program.
	 * @return the arguments that are not recognized as CLI options.
	 */
	def parseCommandLine(args : String[]) : String[]

	/** Add the given entries to the system classpath.
	 * 
	 * @param entries the new classpath entries. The format of the value is the same as for the <code>-cp</code>
	 * command-line option of the <code>java</code> tool.
	 */
	def addToSystemClasspath(entries : String)

	/** 
	 * Replies the console stream for logging messages from the boot mechanism.
	 * 
	 * <p>The console stream is independent of the stream used by the {@link LoggingService logging service} of the platform. Indeed,
	 * the console stream is used for displaying information, warnings and messages before the Janus platform is realy launched.
	 * 
	 * @return the console logger.
	 */
	def getConsoleLogger : PrintStream

	/** 
	 * Replies the console stream for logging messages from the boot mechanism.
	 * 
	 * <p>The console stream is independent of the stream used by the {@link LoggingService logging service} of the platform. Indeed,
	 * the console stream is used for displaying information, warnings and messages before the Janus platform is realy launched.
	 * 
	 * @param stream the stream to use for the console logging.
	 */
	def setConsoleLogger(stream : PrintStream)

	/** 
	 * Replies the command line options supported by this boot class.
	 * 
	 * @return the command line options.
	 */
	def getOptions : Options

	/** 
	 * Show the help message on the standard console. This function never returns.
	 */
	def showHelp(logger : PrintWriter = null)

	/** 
	 * Show the classpath. This function never returns.
	 */
	def showClasspath

	/** 
	 * Show the default values of the system properties. This function never returns.
	 */
	def showDefaults

	/** 
	 * Show the version of Janus. This function never returns.
	 */
	def showVersion

	/** Replies the name of the program.
	 * 
	 * @return the name of the program.
	 */
	def getProgramName : String

	/** 
	 * Show the heading logo of the Janus platform.
	 */
	def showJanusLogo

	/** 
	 * Set offline flag of the Janus platform.
	 * 
	 * <p>This function is equivalent to the command line option <code>-o</code>.
	 * 
	 * <p>This function must be called before launching the Janus platform.
	 * 
	 * @param isOffline the offline flag.
	 * @since 2.0.2.0
	 * @see JanusConfig#OFFLINE
	 */
	def setOffline(isOffline : boolean)

	/** 
	 * Force the Janus platform to use a random identifier for its default context.
	 * 
	 * <p>This function is equivalent to the command line option <code>-R</code>.
	 * 
	 * <p>This function must be called before launching the Janus platform.
	 * 
	 * @since 2.0.2.0
	 * @see JanusConfig#BOOT_DEFAULT_CONTEXT_ID_NAME
	 * @see JanusConfig#RANDOM_DEFAULT_CONTEXT_ID_NAME
	 */
	def setRandomContextUUID

	/** 
	 * Force the Janus platform to use a default context identifier that tis build upon the classname of the boot agent. It means
	 * that the UUID is always the same for a given classname.
	 * 
	 * <p>This function is equivalent to the command line option <code>-B</code>.
	 * 
	 * @since 2.0.2.0
	 * @see JanusConfig#BOOT_DEFAULT_CONTEXT_ID_NAME
	 * @see JanusConfig#RANDOM_DEFAULT_CONTEXT_ID_NAME
	 */
	def setBootAgentTypeContextUUID

	/** 
	 * Force the Janus platform to use the identifier hard-coded in the source code for its default context.
	 * 
	 * <p>This function is equivalent to the command line option <code>-W</code>.
	 * 
	 * <p>This function must be called before launching the Janus platform.
	 * 
	 * @since 2.0.2.0
	 * @see JanusConfig#BOOT_DEFAULT_CONTEXT_ID_NAME
	 * @see JanusConfig#RANDOM_DEFAULT_CONTEXT_ID_NAME
	 */
	def setDefaultContextUUID

	/** 
	 * Force the verbosity level.
	 * 
	 * <p>This function must be called before launching the Janus platform.
	 * 
	 * @param level the verbosity level.
	 * @since 2.0.2.0
	 * @see JanusConfig#VERBOSE_LEVEL_NAME
	 */
	def setVerboseLevel(level : int)

	/** Do any preparing steps for launching the platform.
	 * 
	 * <p>The env. variable that contains the boot agent is set.
	 * 
	 * @param agentType the type of the agent. 
	 * @since 2.0.7.0
	 */
	def prepareJanusStart(agentType : Class<? extends Agent>)

	/** 
	 * Launch the Janus kernel and the first agent in the kernel.
	 * 
	 * <p>Thus function does not parse the command line. See {@link #main(String[])} for the command line management. When this
	 * function is called, it is assumed that all the system's properties are correctly set.
	 * 
	 * <p>The platformModule parameter permits to specify the injection module to use. The injection module is in change of
	 * creating/injecting all the components of the platform. The default injection module is retreived from the system property
	 * with the name stored in {@link JanusConfig#INJECTION_MODULE_NAME}. The default type for the injection module is stored in
	 * the constant {@link JanusConfig#INJECTION_MODULE_NAME_VALUE}.
	 * 
	 * <p>The function {@link #getBootAgentIdentifier()} permits to retreive the identifier of the launched agent.
	 * 
	 * @param agentCls type of the first agent to launch.
	 * @param params parameters to pass to the agent as its initliazation parameters.
	 * @return the kernel that was launched.
	 * @throws Exception - if it is impossible to start the platform.
	 * @see #main(String[])
	 * @see #getBootAgentIdentifier()
	 */
	def startJanus(agentCls : Class<? extends Agent>, params : Object*) : Kernel

	/** 
	 * Launch the Janus kernel and the first agent in the kernel.
	 * 
	 * <p>Thus function does not parse the command line. See {@link #main(String[])} for the command line management. When this
	 * function is called, it is assumed that all the system's properties are correctly set.
	 * 
	 * <p>The platformModule parameter permits to specify the injection module to use. The injection module is in change of
	 * creating/injecting all the components of the platform. The default injection module is retreived from the system property
	 * with the name stored in {@link JanusConfig#INJECTION_MODULE_NAME}. The default type for the injection module is stored in
	 * the constant {@link JanusConfig#INJECTION_MODULE_NAME_VALUE}.
	 * 
	 * <p>The function {@link #getBootAgentIdentifier()} permits to retreive the identifier of the launched agent.
	 * 
	 * @param platformModule type of the injection module to use for initializing the platform, if <code>null</code> the default
	 * module will be used.
	 * @param agentCls type of the first agent to launch.
	 * @param params parameters to pass to the agent as its initliazation parameters.
	 * @return the kernel that was launched.
	 * @throws Exception - if it is impossible to start the platform.
	 * @since 2.0.5.0
	 * @see #main(String[])
	 * @see #getBootAgentIdentifier()
	 */
	def startJanusWithModuleType(platformModule : Class<? extends Module>, agentCls : Class<? extends Agent>,
		params : Object*) : Kernel

	/** 
	 * Launch the Janus kernel and the first agent in the kernel.
	 * 
	 * <p>Thus function does not parse the command line. See {@link #main(String[])} for the command line management. When this
	 * function is called, it is assumed that all the system's properties are correctly set.
	 * 
	 * <p>The startupModule parameter permits to specify the injection module to use. The injection module is in change of
	 * creating/injecting all the components of the platform. The default injection module is retreived from the system property
	 * with the name stored in {@link JanusConfig#INJECTION_MODULE_NAME}. The default type for the injection module is stored in
	 * the constant {@link JanusConfig#INJECTION_MODULE_NAME_VALUE}.
	 * 
	 * <p>The function {@link #getBootAgentIdentifier()} permits to retreive the identifier of the launched agent.
	 * 
	 * @param startupModule the injection module to use for initializing the platform.
	 * @param agentCls type of the first agent to launch.
	 * @param params parameters to pass to the agent as its initliazation parameters.
	 * @return the kernel that was launched.
	 * @throws Exception - if it is impossible to start the platform.
	 * @since 2.0.5.0
	 * @see #main(String[])
	 * @see #getBootAgentIdentifier()
	 */
	def startJanusWithModule(startupModule : Module, agentCls : Class<? extends Agent>, params : Object*) : Kernel

	/** 
	 * Replies the tool for exiting the application.
	 * 
	 * @return the tool for exiting the application.
	 */
	def getExiter : Exiter

	/** 
	 * Changes the tool that permits to stop the application.
	 * 
	 * @param exiter the exit tool.
	 */
	def setExiter(exiter : Exiter)

}

/** 
 * Tool for exiting from the application.
 * 
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
interface Exiter {

	/** 
	 * Exit the application.
	 */
	def exit

}
/** 
 * This is the interface that permits to boot the Janus platform.
 * 
 * <p>This class provides the "main" function for the platform. The list of the parameters is composed of a list of options, the
 * classname of an agent to launch, and the parameters to pass to the launched agent.
 * 
 * <p>The supported options may be obtain by passing no parameter, or the option <code>-h</code>.
 * 
 * <p>Example of Janus launching with Maven:
 * <pre>
 * <code>mvn exec:java
 * -Dexec.mainClass="io.janusproject.Boot"
 * -Dexec.args="my.Agent"</code>
 * </pre>
 * 
 * <p>Example of Janus launching from the CLI (only with the Jar file that is containing all the jar dependencies):
 * <pre>
 * <code>java -jar janus-with-dependencies.jar my.Agent</code>
 * </pre>
 * 
 * @author $Author: srodriguez$
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
final class Boot {

	private new {
	}

	/** Replies the Janus booter.
	 * @return the Janus booter.
	 */
	static def getBooter : Booter {
		var bootstrap = SRE::bootstrap
		if (bootstrap instanceof Booter) {
			return bootstrap
		}
		var booter = new JanusBooter
		SRE::bootstrap = booter
		return booter
	}

	/** Change the Janus booter.
	 * @param janusBooter the Janus booter.
	 */
	static def setBooter(janusBooter : Booter) {
		SRE::bootstrap = janusBooter
	}

	/** 
	 * Main function that is parsing the command line and launching the first agent.
	 * 
	 * @param args command line arguments
	 * @see #startJanus(Class, Object...)
	 */
	static def main(args : String*) {
		getBooter.runStandardBootProcess(args)
	}

	/** Add the given entries to the system classpath.
	 * 
	 * @param entries the new classpath entries. The format of the value is the same as for the <code>-cp</code>
	 * command-line option of the <code>java</code> tool.
	 */
	static def addToSystemClasspath(entries : String) {
		getBooter.addToSystemClasspath(entries)
	}

	/** 
	 * Replies the console stream for logging messages from the boot mechanism.
	 * 
	 * <p>The console stream is independent of the stream used by the {@link LoggingService logging service} of the platform. Indeed,
	 * the console stream is used for displaying information, warnings and messages before the Janus platform is realy launched.
	 * 
	 * @return the console logger.
	 */
	static def getConsoleLogger : PrintStream {
		getBooter.consoleLogger
	}

	/** 
	 * Replies the console stream for logging messages from the boot mechanism.
	 * 
	 * <p>The console stream is independent of the stream used by the {@link LoggingService logging service} of the platform. Indeed,
	 * the console stream is used for displaying information, warnings and messages before the Janus platform is realy launched.
	 * 
	 * @param stream the stream to use for the console logging.
	 */
	static def setConsoleLogger(stream : PrintStream) {
		getBooter.consoleLogger = stream
	}

	/** 
	 * Show the help message on the standard console. This function never returns.
	 */
	static def showHelp(logger : PrintWriter = null) {
		getBooter.showHelp(logger)
	}

	/** 
	 * Show the classpath. This function never returns.
	 */
	static def showClasspath {
		getBooter.showClasspath
	}

	/** 
	 * Show the default values of the system properties. This function never returns.
	 */
	static def showDefaults {
		getBooter.showDefaults
	}

	/** 
	 * Show the version of Janus. This function never returns.
	 */
	static def showVersion {
		getBooter.showVersion
	}

	/** Replies the name of the program.
	 * 
	 * @return the name of the program.
	 */
	static def getProgramName : String {
		getBooter.programName
	}

	/** 
	 * Show the heading logo of the Janus platform.
	 */
	static def showJanusLogo {
		getBooter.showJanusLogo
	}

	/** 
	 * Set offline flag of the Janus platform.
	 * 
	 * <p>This function is equivalent to the command line option <code>-o</code>.
	 * 
	 * <p>This function must be called before launching the Janus platform.
	 * 
	 * @param isOffline the offline flag.
	 * @since 2.0.2.0
	 * @see JanusConfig#OFFLINE
	 */
	static def setOffline(isOffline : boolean) {
		getBooter.offline = isOffline
	}

	/** 
	 * Force the Janus platform to use a random identifier for its default context.
	 * 
	 * <p>This function is equivalent to the command line option <code>-R</code>.
	 * 
	 * <p>This function must be called before launching the Janus platform.
	 * 
	 * @since 2.0.2.0
	 * @see JanusConfig#BOOT_DEFAULT_CONTEXT_ID_NAME
	 * @see JanusConfig#RANDOM_DEFAULT_CONTEXT_ID_NAME
	 */
	static def setRandomContextUUID {
		getBooter.setRandomContextUUID
	}

	/** 
	 * Force the Janus platform to use a default context identifier that tis build upon the classname of the boot agent. It means
	 * that the UUID is always the same for a given classname.
	 * 
	 * <p>This function is equivalent to the command line option <code>-B</code>.
	 * 
	 * @since 2.0.2.0
	 * @see JanusConfig#BOOT_DEFAULT_CONTEXT_ID_NAME
	 * @see JanusConfig#RANDOM_DEFAULT_CONTEXT_ID_NAME
	 */
	static def setBootAgentTypeContextUUID {
		getBooter.setBootAgentTypeContextUUID
	}

	/** 
	 * Force the Janus platform to use the identifier hard-coded in the source code for its default context.
	 * 
	 * <p>This function is equivalent to the command line option <code>-W</code>.
	 * 
	 * <p>This function must be called before launching the Janus platform.
	 * 
	 * @since 2.0.2.0
	 * @see JanusConfig#BOOT_DEFAULT_CONTEXT_ID_NAME
	 * @see JanusConfig#RANDOM_DEFAULT_CONTEXT_ID_NAME
	 */
	static def setDefaultContextUUID {
		getBooter.setDefaultContextUUID
	}

	/** 
	 * Force the verbosity level.
	 * 
	 * <p>This function must be called before launching the Janus platform.
	 * 
	 * @param level the verbosity level.
	 * @since 2.0.2.0
	 * @see JanusConfig#VERBOSE_LEVEL_NAME
	 */
	static def setVerboseLevel(level : int) {
		getBooter.verboseLevel = level
	}

	/** 
	 * Replies the identifier of the boot agent from the system's properties. The boot agent is launched with
	 * {@link #startJanus(Class, Object...)}.
	 * 
	 * @return the identifier of the boot agent, or <code>null</code> if it is unknown.
	 * @since 2.0.2.0
	 * @see JanusConfig#BOOT_AGENT_ID
	 * @see #startJanus(Class, Object...)
	 */
	static def getBootAgentIdentifier : UUID {
		getBooter.bootAgentIdentifier
	}

	/** 
	 * Launch the Janus kernel and the first agent in the kernel.
	 * 
	 * <p>Thus function does not parse the command line. See {@link #main(String[])} for the command line management. When this
	 * function is called, it is assumed that all the system's properties are correctly set.
	 * 
	 * <p>The platformModule parameter permits to specify the injection module to use. The injection module is in change of
	 * creating/injecting all the components of the platform. The default injection module is retreived from the system property
	 * with the name stored in {@link JanusConfig#INJECTION_MODULE_NAME}. The default type for the injection module is stored in
	 * the constant {@link JanusConfig#INJECTION_MODULE_NAME_VALUE}.
	 * 
	 * <p>The function {@link #getBootAgentIdentifier()} permits to retreive the identifier of the launched agent.
	 * 
	 * @param agentCls type of the first agent to launch.
	 * @param params parameters to pass to the agent as its initliazation parameters.
	 * @return the kernel that was launched.
	 * @throws Exception - if it is impossible to start the platform.
	 * @see #main(String[])
	 * @see #getBootAgentIdentifier()
	 */
	static def startJanus(agentCls : Class<? extends Agent>, params : Object*) : Kernel {
		getBooter.startJanus(agentCls, params)
	}

	/** 
	 * Launch the Janus kernel and the first agent in the kernel.
	 * 
	 * <p>Thus function does not parse the command line. See {@link #main(String[])} for the command line management. When this
	 * function is called, it is assumed that all the system's properties are correctly set.
	 * 
	 * <p>The platformModule parameter permits to specify the injection module to use. The injection module is in change of
	 * creating/injecting all the components of the platform. The default injection module is retreived from the system property
	 * with the name stored in {@link JanusConfig#INJECTION_MODULE_NAME}. The default type for the injection module is stored in
	 * the constant {@link JanusConfig#INJECTION_MODULE_NAME_VALUE}.
	 * 
	 * <p>The function {@link #getBootAgentIdentifier()} permits to retreive the identifier of the launched agent.
	 * 
	 * @param platformModule type of the injection module to use for initializing the platform, if <code>null</code> the default
	 * module will be used.
	 * @param agentCls type of the first agent to launch.
	 * @param params parameters to pass to the agent as its initliazation parameters.
	 * @return the kernel that was launched.
	 * @throws Exception - if it is impossible to start the platform.
	 * @since 2.0.5.0
	 * @see #main(String[])
	 * @see #getBootAgentIdentifier()
	 */
	static def startJanusWithModuleType(platformModule : Class<? extends Module>, agentCls : Class<? extends Agent>,
		params : Object*) : Kernel {
		getBooter.startJanusWithModuleType(platformModule, agentCls, params)
	}

	/** 
	 * Launch the Janus kernel and the first agent in the kernel.
	 * 
	 * <p>Thus function does not parse the command line. See {@link #main(String[])} for the command line management. When this
	 * function is called, it is assumed that all the system's properties are correctly set.
	 * 
	 * <p>The startupModule parameter permits to specify the injection module to use. The injection module is in change of
	 * creating/injecting all the components of the platform. The default injection module is retreived from the system property
	 * with the name stored in {@link JanusConfig#INJECTION_MODULE_NAME}. The default type for the injection module is stored in
	 * the constant {@link JanusConfig#INJECTION_MODULE_NAME_VALUE}.
	 * 
	 * <p>The function {@link #getBootAgentIdentifier()} permits to retreive the identifier of the launched agent.
	 * 
	 * @param startupModule the injection module to use for initializing the platform.
	 * @param agentCls type of the first agent to launch.
	 * @param params parameters to pass to the agent as its initliazation parameters.
	 * @return the kernel that was launched.
	 * @throws Exception - if it is impossible to start the platform.
	 * @since 2.0.5.0
	 * @see #main(String[])
	 * @see #getBootAgentIdentifier()
	 */
	static def startJanusWithModule(startupModule : Module, agentCls : Class<? extends Agent>,
		params : Object*) : Kernel {
		getBooter.startJanusWithModule(startupModule, agentCls, params)
	}

}
