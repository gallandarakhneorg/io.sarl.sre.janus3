/*
 * $Id$
 *
 * SARL is an general-purpose agent programming language.
 * More details on http://www.sarl.io
 *
 * Copyright (C) 2014-2017 the original authors or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.janusproject.sre.services

import com.google.common.collect.Multimap
import com.google.common.util.concurrent.Service
import io.janusproject.sre.services.infrastructure.InfrastructureService
import io.sarl.util.Comparators
import java.lang.ref.WeakReference
import java.text.MessageFormat
import java.util.Collection
import java.util.List
import java.util.Map
import java.util.Queue
import java.util.logging.Logger

/**
 * Manager of services for the Janus platform.
 * 
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
interface IServiceManager {

	/** 
	 * Replies the services by state.
	 * 
	 * @return the services.
	 */
	def getServicesByState : Multimap<Service.State, Service>
	
	/**
	 * Replies the service of the given type.
	 * 
	 * @param type the type of the service to search for.
	 * @return the service
	 */
	def getService(type : Class<T>) : T with T extends Service
	
	/** 
	 * Wait for all the services are started.
	 */
	def awaitHealthy

	/**
	 * Wait for all the services are stopped.
	 */
	def awaitStopped
	
	/** 
	 * Start the services associated to the service manager.
	 * 
	 * <p>This starting function supports the {@link DependentService prioritized services}.
	 * 
	 * @param logger the logger to use for any information message.
	 */
	def startServices(logger : Logger)

	/** 
	 * Stop the services associated to the service manager.
	 * 
	 * <p>This stopping function supports the {@link DependentService prioritized services}.
	 *
	 * @param logger the logger to use for any information message.
	 */
	def stopServices(logger : Logger)

}

/** 
 * Abstract implementation of a service manager for the Janus platform.
 * 
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
abstract class AbstractServiceManager implements IServiceManager {

	def startServices(logger : Logger) {
		val otherServices = <Service>newArrayList
		val infraServices = <Service>newArrayList
		val serviceQueue = <DependencyNode>newLinkedList
		val accessors = new StartingPhaseAccessors

		// Build the dependency graph
		buildDependencyGraph(logger, serviceQueue, infraServices, otherServices, accessors)

		// Launch the services in the right order
		runDependencyGraph(logger, serviceQueue, infraServices, otherServices, accessors)

		logger.fine(Messages::AbstractServiceManager_1)
		awaitHealthy
	}

	def stopServices(logger : Logger) {
		preStop(logger)
		
		val otherServices = <Service>newArrayList
		val infraServices = <Service>newArrayList
		val serviceQueue = <DependencyNode>newLinkedList
		val accessors = new StoppingPhaseAccessors(logger)

		// Build the dependency graph
		buildInvertedDependencyGraph(logger, serviceQueue, infraServices, otherServices, accessors)

		// Stop the services in the right order
		runDependencyGraph(logger, serviceQueue, infraServices, otherServices, accessors)

		// stop the services that are not yet stopped
		logger.fine(Messages::AbstractServiceManager_3)
		internalStopAllServices

		// Await for stop
		logger.fine(Messages::AbstractServiceManager_0)
		awaitStopped
	}

	/** Pre-stop all the services that are implemented {@link */
	protected def preStop(logger : Logger) : void {
		logger.fine(Messages::AbstractServiceManager_4)
		for (service : servicesByState.values) {
			if (service.isRunning && service instanceof PreReleasableService) {
				(service as PreReleasableService).onPreStop
			}
		}
	}

	/** Stop all the services whatever the dependencies between the services. */
	protected abstract def internalStopAllServices

	private static def addNodeIntoDependencyGraph(depServ : DependentService,
			dependentServices : Map<Class<? extends Service>, DependencyNode>,
			roots : List<DependencyNode>) {
		val type = depServ.serviceType
		assert type !== null
		assert type.isInterface
		var node = dependentServices.get(type)
		if (node === null) {
			node = new DependencyNode(depServ, type)
			dependentServices.put(type, node)
		} else {
			assert node.service === null
			node.service = depServ
		}

		var isRoot = true
		var deps = depServ.serviceDependencies
		for (dep : deps) {
			isRoot = false
			var depNode = dependentServices.get(dep)
			if (depNode === null) {
				depNode = new DependencyNode(dep)
				dependentServices.put(dep, depNode)
			}
			depNode.nextServices += node
		}

		deps = depServ.serviceWeakDependencies
		for (dep : deps) {
			isRoot = false;
			var depNode = dependentServices.get(dep)
			if (depNode === null) {
				depNode = new DependencyNode(dep)
				dependentServices.put(dep, depNode)
			}
			depNode.nextWeakServices += node
		}

		if (isRoot) {
			roots += node
		}
	}

	/** 
	 * Build the dependency graph for the services.
	 * 
	 * @param logger the logger.
	 * @param roots filled with the services that have no dependency.
	 * @param infraServices filled with the infrastructure services.
	 * @param freeServices filled with the services that are executed before/after all the dependent services.
	 * @param accessors permits to retrieve information on the services.
	 */
	private def buildDependencyGraph(logger : Logger, roots : List<DependencyNode>
, infraServices : List<Service>,
			freeServices : List<Service>, accessors : Accessors) {
		val dependentServices : Map<Class<? extends Service>, DependencyNode> = newTreeMap(Comparators::classComparator)
		for (entry : servicesByState.entries) {
			if (accessors.matches(entry.key)) {
				var service = entry.value
				if (service instanceof InfrastructureService) {
					infraServices += service
				} else if (service instanceof DependentService) {
					service.addNodeIntoDependencyGraph(dependentServices, roots)
				} else {
					freeServices += service
				}
			}
		}

		if (accessors.asyncStateWaitingEnabled) {
			for (node : dependentServices.values) {
				assert node.service !== null
				if (node.service instanceof AsyncStateService) {
					for (next : node.nextServices) {
						next.asyncStateServices += new WeakReference(node)
					}
				}
			}
		}

		logger.fine [MessageFormat::format(Messages::AbstractServiceManager_2,
			infraServices.toString, roots.toString, freeServices.toString)]
	}

	/** 
	 * Build the dependency graph for the services.
	 * 
	 * @param logger the logger
	 * @param roots filled with the services that have no dependency.
	 * @param infraServices filled with the infrastructure services.
	 * @param freeServices filled with the services that are executed before/after all the dependent services.
	 * @param accessors permits to retrieve information on the services.
	 */
	private def buildInvertedDependencyGraph(logger : Logger, roots : List<DependencyNode>,
			infraServices : List<Service>, freeServices : List<Service>, accessors : Accessors) {
		val dependentServices : Map<Class<? extends Service>, DependencyNode> = newTreeMap(Comparators::classComparator)
		val rootServices : Map<Class<? extends Service>, DependencyNode> = newTreeMap(Comparators::classComparator)

		for (entry : servicesByState.entries) {
			if (accessors.matches(entry.key)) {
				var service = entry.value
				if (service instanceof InfrastructureService) {
					infraServices += service
				} else if (service instanceof DependentService) {
					val type = service.serviceType
					var node = dependentServices.get(type)
					var isRoot = true
					if (node === null) {
						node = new DependencyNode(service, type)
						dependentServices.put(type, node)
					} else {
						assert node.service === null
						node.service = service
						isRoot = false
					}

					var deps = service.serviceDependencies
					for (dep : deps) {
						var depNode = dependentServices.get(dep)
						if (depNode === null) {
							depNode = new DependencyNode(dep)
							dependentServices.put(dep, depNode)
						}
						node.nextServices += depNode
						rootServices.remove(depNode.type)
					}

					deps = service.serviceWeakDependencies
					for (dep : deps) {
						var depNode = dependentServices.get(dep)
						if (depNode === null) {
							depNode = new DependencyNode(dep)
							dependentServices.put(dep, depNode)
						}
						node.nextWeakServices += depNode
						rootServices.remove(depNode.type)
					}

					if (isRoot) {
						rootServices.put(type, node)
					}
				} else {
					freeServices += service
				}
			}
		}

		roots += rootServices.values

		logger.fine [
			MessageFormat::format(Messages::AbstractServiceManager_2, infraServices.toString, roots.toString,
				freeServices.toString)
		]
	}

	/** 
	 * Run the dependency graph for the services.
	 * 
	 * @param logger the logger.
	 * @param roots filled with the services that have no dependency.
	 * @param infraServices filled with the infrastructure services.
	 * @param freeServices filled with the services that are executed before/after all the dependent services.
	 * @param accessors permits to retrieve information on the services.
	 */
	private static def runDependencyGraph(logger : Logger, roots : Queue<DependencyNode>, infraServices : List<Service>,
		freeServices : List<Service>, accessors : Accessors) {
		val async = accessors.asyncStateWaitingEnabled
		val executed = newTreeSet(Comparators::classComparator)
		accessors.runInfrastructureServicesBefore(logger, infraServices)
		accessors.runFreeServicesBefore(logger, freeServices)
		while (!roots.empty) {
			val node = roots.remove
			assert node !== null && node.type !== null
			if (!executed.contains(node.type)) {
				executed += node.type
				roots += node.nextServices
				roots += node.nextWeakServices
				assert node.service !== null
				if (async) {
					for (asyncService : node.asyncStateServices) {
						val ^as = asyncService.get.service as AsyncStateService
						assert ^as !== null
						while (!^as.readyForOtherServices) {
							Thread::yield
						}
					}
				}
				accessors.run(logger, node.service)
			}
		}
		accessors.runFreeServicesAfter(logger, freeServices)
		accessors.runInfrastructureServicesAfter(logger, infraServices)
	}

	/** 
	 * Node that describes a service dependency.
	 * 
	 * @author $Author: sgalland$
	 * @version $FullVersion$
	 * @mavengroupid $GroupId$
	 * @mavenartifactid $ArtifactId$
	 */
	private static class DependencyNode {
	
		var service : Service
	
		val type : Class<? extends Service>

		val nextServices : Collection<DependencyNode> = newArrayList

		val nextWeakServices : Collection<DependencyNode> = newArrayList

		val asyncStateServices : Collection<WeakReference<DependencyNode>> = newArrayList

		new (service : DependentService = null, type : Class<? extends Service>) {
			this.service = service
			this.type = type
		}

		def getService : Service {
			this.service
		}

		def setService(service : Service) {
			this.service = service
		}

		def getType : Class<? extends Service> {
			this.type
		}

		def getAsyncStateServices : Collection<WeakReference<DependencyNode>> {
			this.asyncStateServices
		}

		def getNextServices : Collection<DependencyNode> {
			this.nextServices
		}

		def getNextWeakServices : Collection<DependencyNode> {
			this.nextWeakServices
		}

		def toString : String {
			if (this.service === null) {
				return "!!!" + this.type.name
			}
			return this.service.toString
		}

	}

	/**
	 * Accessors for running services.
	 *
	 * @author $Author: sgalland$
	 * @version $FullVersion$
	 * @mavengroupid $GroupId$
	 * @mavenartifactid $ArtifactId$
	 */
	private interface Accessors {

		def matches(element : Service.State) : boolean 

		def runInfrastructureServicesBefore(logger : Logger, infraServices : List<Service>)

		def runFreeServicesBefore(flogger : Logger, reeServices : List<Service>)

		def isAsyncStateWaitingEnabled : boolean

		def run(logger : Logger, service : Service)

		def runFreeServicesAfter(logger : Logger, freeServices : List<Service>)

		def runInfrastructureServicesAfter(logger : Logger, infraServices : List<Service>)

	}

	/**
	 * Accessors for running services at start-up.
	 *
	 * @author $Author: sgalland$
	 * @version $FullVersion$
	 * @mavengroupid $GroupId$
	 * @mavenartifactid $ArtifactId$
	 */
	private static class StartingPhaseAccessors implements Accessors {

		def matches(element : Service.State) : boolean {
			element == Service.State::NEW
		}

		def runFreeServicesBefore(logger : Logger, freeServices : List<Service>) {
		}

		def runInfrastructureServicesBefore(logger : Logger, infraServices : List<Service>) {
			for (serv : infraServices) {
				logger.fine [MessageFormat::format(Messages::StartingPhaseAccessors_1, serv.class.simpleName)]
				serv.startAsync.awaitRunning
				logger.finer [MessageFormat::format(Messages::StartingPhaseAccessors_2, serv.class.simpleName)]
			}
		}

		def isAsyncStateWaitingEnabled : boolean {
			true
		}

		def run(logger : Logger, service : Service) {
			logger.fine [MessageFormat::format(Messages::StartingPhaseAccessors_1, service.class.simpleName)]
			service.startAsync.awaitRunning
			logger.finer[MessageFormat::format(Messages::StartingPhaseAccessors_2, service.class.simpleName)]
		}

		def runFreeServicesAfter(logger : Logger, freeServices : List<Service>) {
			for (serv : freeServices) {
				logger.fine [MessageFormat::format(Messages::StartingPhaseAccessors_0, serv.class.simpleName)]
				serv.startAsync
			}
		}

		def runInfrastructureServicesAfter(logger : Logger, infraServices : List<Service>) {
			//
		}

	}

	/**
	 * Accessors for running agents at end.
	 *
	 * @author $Author: sgalland$
	 * @version $FullVersion$
	 * @mavengroupid $GroupId$
	 * @mavenartifactid $ArtifactId$
	 */
	private static class StoppingPhaseAccessors implements Accessors {

		val logger : Logger

		new (logger : Logger) {
			this.logger = logger
		}

		def matches(element : Service.State) : boolean {
			element != Service.State::TERMINATED && element != Service.State::STOPPING
		}

		def runFreeServicesBefore(logger : Logger, freeServices : List<Service>) {
			for (serv : freeServices) {
				this.logger.fine [MessageFormat::format(Messages::StoppingPhaseAccessors_0, serv.class.simpleName)]
				serv.stopAsync
			}
		}

		def runInfrastructureServicesBefore(logger : Logger, infraServices : List<Service>) {
			//
		}

		def isAsyncStateWaitingEnabled : boolean {
			false
		}

		def run(logger : Logger, service : Service) {
			this.logger.fine [MessageFormat::format(Messages::StoppingPhaseAccessors_1, service.class.simpleName)]
			service.stopAsync
			service.awaitTerminated
			this.logger.finer [MessageFormat::format(Messages::StoppingPhaseAccessors_2, service.class.simpleName)]
		}

		def runFreeServicesAfter(logger : Logger, freeServices : List<Service>) {
			//
		}

		def runInfrastructureServicesAfter(logger : Logger, infraServices : List<Service>) {
			for (serv : infraServices) {
				this.logger.fine [MessageFormat::format(Messages::StoppingPhaseAccessors_0, serv.class.simpleName)]
				serv.stopAsync
			}
		}

	}

}
