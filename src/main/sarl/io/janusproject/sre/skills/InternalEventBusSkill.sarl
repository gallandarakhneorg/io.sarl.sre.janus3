/*
 * $Id$
 *
 * SARL is an general-purpose agent programming language.
 * More details on http://www.sarl.io
 *
 * Copyright (C) 2014-2018 the original authors or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.janusproject.sre.skills

import io.janusproject.sre.capacities.InternalEventBusCapacity
import io.janusproject.sre.services.executor.ExecutorService
import io.sarl.core.Logging
import io.sarl.lang.core.Event
import io.sarl.lang.core.EventListener
import io.sarl.lang.util.SynchronizedIterable
import io.sarl.revision.BehaviorGuardEvaluator
import io.sarl.revision.BehaviorGuardEvaluatorRegistry
import io.sarl.util.Collections3
import java.lang.ref.WeakReference
import java.util.Collection
import java.util.LinkedList
import java.util.List
import java.util.UUID
import java.util.concurrent.atomic.AtomicBoolean
import java.util.logging.Logger
import javax.inject.Inject
import org.arakhne.afc.util.MultiCollection

import static io.janusproject.sre.skills.InternalEventBusSkill.BinFlags.*

import static extension io.janusproject.sre.services.lifecycle.AgentLife.*

/** 
 * Janus implementation of an internal skill that provides an event dispatcher to notify the different components/behaviors of an
 * agent.
 * 
 * @author $Author: srodriguez$
 * @author $Author: ngaud$
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
skill InternalEventBusSkill extends JanusBuiltin implements InternalEventBusCapacity {

	uses Logging

	private static class BinFlags {
		static var installationOrder = -1
	}

	override getInstallationOrder : int {
		if (BinFlags::installationOrder < 0) {
			BinFlags::installationOrder = BuiltinCapacitiesOrder::computeInstallationOrder(this)
		}
		BinFlags::installationOrder
	}
	
	var eventBus : EventBus
	
	var eventListener : EventListener

	val isEventBufferEnabled = new AtomicBoolean

	var eventBuffer : List<Event> = null

	/** Set the backend event bus.
	 */
	@Inject
	def setEventBus(bus : EventBus) {
		this.eventBus = bus
	}

	protected override install {
		// Register the agent as a direct event listener.
		var bus = this.eventBus
		if (bus !== null) {
			bus.register(this.owner, null, null)
		}
	}

	protected override uninstall(stage : UninstallationStage) {
		if (stage == UninstallationStage::POST_DESTROY_EVENT) {
			var bus = this.eventBus
			if (bus !== null) {
				bus.unregisterAll(null)
			}
			this.eventListener = null
			this.eventBuffer = null;
		}
	}

	final def getAssociatedEventBusListener : EventListener {
		if (this.eventListener === null) {
			this.eventListener = new ExternalEventBusAccessor(owner.ID, this)
		}
		return this.eventListener
	}

	def registerEventBusListener(listener : Object, filter : (Event)=>boolean, callback : (Object)=>void) {
		this.eventBus.register(listener, filter, callback);
	}

	def unregisterEventBusListener(listener : Object, callback : (Object)=>void = null) {
		this.eventBus.unregister(listener, callback)
	}

	def unregisterEventBusListener(listenerType : Class<?>, callback : (Object)=>void = null) {
		this.eventBus.unregister(listenerType, callback)
	}

	/** Change the event buffering flag.
	 *
	 * @param buffering the value of the flag.
	 * @return the value of the flag before its change.
	 */
	def setEventBuffering(buffering : boolean) : boolean {
		this.isEventBufferEnabled.getAndSet(buffering)
	}

	/** Replies if the events are buffering.
	 * 
	 * @return {@code true} if the events are buffered.
	 */
	def isEventBuffering() : boolean {
		this.isEventBufferEnabled.get
	}

	/** Replies the buffered events.
	 *
	 * @return an unmodifiable iterable of the buffered elements.
	 */
	def getBufferedEvents : SynchronizedIterable<Event> {
		synchronized (this.isEventBufferEnabled) {
			if (this.eventBuffer === null) {
				return Collections3::emptySynchronizedSet
			}
			return Collections3::unmodifiableSynchronizedIterable(this.eventBuffer, this.isEventBufferEnabled);
		}
	}

	def fireEventAndWait(^event : Event, gatherEvents : boolean, thrownExceptions : boolean,
		listener : Object) : Iterable<Event> {
		if (owner.life.state.blockingEventHandling) {
			if (gatherEvents) {
				val wasEnabled = this.isEventBufferEnabled.getAndSet(true)
				try {
					this.eventBus.immediateDispatchTo(listener, ^event, thrownExceptions, getLogger)
				} finally {
					this.isEventBufferEnabled.set(wasEnabled)
				}
				var cache : List<Event>
				synchronized (this.isEventBufferEnabled) {
					cache = this.eventBuffer
					this.eventBuffer = null
				}
				return cache
			}
			this.eventBus.immediateDispatchTo(listener, ^event, thrownExceptions, getLogger)
		}
		return emptyList
	}

	def fireEventAndWait(^event : Event, gatherEvents : boolean, thrownExceptions : boolean) : Iterable<Event> {
		if (owner.life.state.blockingEventHandling) {
			if (gatherEvents) {
				val wasEnabled = this.isEventBufferEnabled.getAndSet(true)
				try {
					this.eventBus.immediateDispatch(^event, thrownExceptions, getLogger)
				} finally {
					this.isEventBufferEnabled.set(wasEnabled)
				}
				var cache : List<Event>
				synchronized (this.isEventBufferEnabled) {
					cache = this.eventBuffer
					this.eventBuffer = null
				}
				return cache
			}
			this.eventBus.immediateDispatch(^event, thrownExceptions, getLogger)
		}
		return emptyList
	}

	
	def fireEvent(^event : Event) {
		if (owner.life.state.asynchronousEventHandling) {
			if (this.isEventBufferEnabled.get) {
				synchronized (this.isEventBufferEnabled) {
					if (this.eventBuffer === null) {
						this.eventBuffer = new LinkedList
					}
					this.eventBuffer += ^event
				}
			} else {
				this.eventBus.asyncDispatch(^event, getLogger)
			}
		}
	}

	def getRegisteredEventBusListeners(type : Class<T>) : SynchronizedIterable<T> with T {
		this.eventBus.getRegisteredEventListeners(type)
	}
	
	/**
	 * The class in charge of dispatching every single events coming from the outside of this agent (i.e. from a space) or from an
	 * agent's behavior.
	 * 
	 * @author $Author: sgalland$
	 * @version $FullVersion$
	 * @mavengroupid $GroupId$
	 * @mavenartifactid $ArtifactId$
	 * 
	 */
	private static class ExternalEventBusAccessor implements EventListener {

		val owner : WeakReference<InternalEventBusCapacity>

		val id : UUID
		
		new (id : UUID, owner : InternalEventBusCapacity) {
			this.id = id
			this.owner = new WeakReference(owner)
		}
	
		override receiveEvent(^event : Event) {
			this.owner.get.fireEvent(^event)
		}
		
		override getID : UUID {
			this.id
		}
		
	}	
	
}

/** 
 * The class in charge of dispatching every single events coming from the outside of this agent (i.e. from a space) or from an
 * agent's behavior.
 * 
 * @author $Author: ngaud$
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 * 
 */
class EventBus {

	/** 
	 * The registry of all {@code BehaviorGuardEvaluator} classes containing a method to evaluate the guard of a given behavior
	 * ("on" clause in SARL behavior). This class has been inspired by the com.google.common.eventbus.SuscriberRegistry class of
	 * Google Guava library.
	 */
	val behaviorGuardEvaluatorRegistry : BehaviorGuardEvaluatorRegistry

	/**
	 * The executor used to execute behavior methods in dedicated thread.
	 */
	val executor : ExecutorService

	/** 
	 * Instantiates a dispatcher.
	 * 
	 * @param executor the executor service.
	 */
	@Inject
	new (executor : ExecutorService) {
		this(executor, new BehaviorGuardEvaluatorRegistry)
	}

	/** 
	 * Instantiates a dispatcher.
	 * 
	 * @param executor the executor service.
	 */
	new (executor : ExecutorService, dispatcher : BehaviorGuardEvaluatorRegistry) {
		assert executor !== null
		assert dispatcher !== null
		this.executor = executor
		this.behaviorGuardEvaluatorRegistry = dispatcher
	}

	/** Replies if a listener with the given type is registered.
	 *
	 * @param type the type of listener.
	 * @return {@code true} if a listener of the given type is registered.
	 * @since 2.0.5.0
	 */
	def hasRegisteredEventListener(type : Class<?>) : boolean {
		synchronized (this.behaviorGuardEvaluatorRegistry) {
			this.behaviorGuardEvaluatorRegistry.hasRegisteredEventListener(type)
		}
	}

	/** Extract the registered listeners with the given type.
	 *
	 * @param <T> the type of the listeners.
	 * @param type the type of the listeners.
	 * @param collection the collection of listeners that is filled by this function.
	 * @return the number of listeners added to the collection.
	 * @since 2.0.6.0
	 */
	def getRegisteredEventListeners(type : Class<T>) : SynchronizedIterable<T> with T {
		synchronized (this.behaviorGuardEvaluatorRegistry) {
			Collections3::unmodifiableSynchronizedIterable(
				this.behaviorGuardEvaluatorRegistry.getRegisteredEventListeners(type),
				this.behaviorGuardEvaluatorRegistry)
		}
	}

	/** 
	 * Registers all {@code PerceptGuardEvaluator} methods on {@code object} to receive events.
	 *
	 * <p>If the filter is provided, it will be used for determining if the given behavior accepts a specific event.
	 * If the filter function replies {@code true} for a specific event as argument, the event is fired in the
	 * behavior context. If the filter function replies {@code false}, the event is not fired in the behavior context.
	 *
	 * @param object object whose {@code PerceptGuardEvaluator} methods should be registered.
	 * @param filter the filter function. It could be {@code null}.
	 * @param callback function which is invoked just after the first registration of the object. It could be {@code null}.
	 */
	def register(object : Object, filter : (Event)=>boolean, callback : (Object)=>void) {
		synchronized (this.behaviorGuardEvaluatorRegistry) {
			this.behaviorGuardEvaluatorRegistry.register(object, filter, callback)
		}
	}

	/**
	 * Unregisters all {@code PerceptGuardEvaluator} methods on a registered {@code object}.
	 *
	 * @param object object whose {@code PerceptGuardEvaluator} methods should be unregistered.
	 * @param callback function which is invoked just before the object is unregistered.
	 * @throws IllegalArgumentException if the object was not previously registered.
	 */
	def unregister(object : Object, callback : (Object)=>void) {
		synchronized (this.behaviorGuardEvaluatorRegistry) {
			this.behaviorGuardEvaluatorRegistry.unregister(object, callback)
		}
	}

	/**
	 * Unregisters all {@code PerceptGuardEvaluator} methods on the objects of the given type.
	 * 
	 * @param type type of the objects whose {@code PerceptGuardEvaluator} methods should be unregistered.
	 * @param callback function which is invoked just before the object is unregistered.
	 * @throws IllegalArgumentException if the object was not previously registered.
	 * @since 2.0.7.0
	 */
	def unregister(type : Class<?>, callback : (Object)=>void) {
		synchronized (this.behaviorGuardEvaluatorRegistry) {
			this.behaviorGuardEvaluatorRegistry.unregister(type, callback)
		}
	}

	/**
	 * Unregisters all {@code PerceptGuardEvaluator} methods on all registered objects.
	 *
	 * @param callback function which is invoked just before the object is unregistered.
	 * @throws IllegalArgumentException if the object was not previously registered.
	 */
	def unregisterAll(callback : (Object)=>void) {
		synchronized (this.behaviorGuardEvaluatorRegistry) {
			this.behaviorGuardEvaluatorRegistry.unregisterAll(callback)
		}
	}

	/**
	 * Posts an event to all registered {@code BehaviorGuardEvaluator}.
	 * The dispatch of this event will be done synchronously.
	 * This method will return successfully after the event has been posted to all {@code BehaviorGuardEvaluator}, and regardless
	 * of any exceptions thrown by {@code BehaviorGuardEvaluator}.
	 *
	 * @param event an event to dispatch synchronously.
	 * @param thrownExceptions indicates if the exceptions in the event handlers should be thrown from this function,
	 *    or logged out to the agent's log.
	 * @param logger the logger to use for notifying the errors.
	 */
	def immediateDispatch(^event : Event, thrownExceptions : boolean, logger : Logger = null) {
		assert ^event !== null
		var behaviorGuardEvaluators : Iterable<BehaviorGuardEvaluator> = null
		synchronized (this.behaviorGuardEvaluatorRegistry) {
			behaviorGuardEvaluators = this.behaviorGuardEvaluatorRegistry.getBehaviorGuardEvaluators(^event)
		}
		if (behaviorGuardEvaluators !== null) {
			var behaviorsMethodsToExecute = ^event.evaluateGuards(behaviorGuardEvaluators, logger)
			if (!behaviorsMethodsToExecute.empty) {
				behaviorsMethodsToExecute.executeBehaviorMethodsInParalellWithSynchroAtTheEnd(thrownExceptions, logger)
			}
		}
		/*
		 * <p>If no {@code BehaviorGuardEvaluator} have been subscribed for {@code event}'s class, and {@code event} is not already a
		 * {@link DeadEvent}, it will be wrapped in a DeadEvent and reposted.
		 */
		// XXX: not in the SARL specifications. Should we fire the DeadEvent?
		/*else if (!(event instanceof DeadEvent)) {
			// the event had no subscribers and was not itself a DeadEvent
			immediateDispatch(new DeadEvent(event));
		}*/
	}

	/**
	 * Posts an event to the registered {@code BehaviorGuardEvaluator} of the given listener only.
	 * The dispatch of this event will be done synchronously.
	 * This method will return successfully after the event has been posted to all {@code BehaviorGuardEvaluator}, and regardless
	 * of any exceptions thrown by {@code BehaviorGuardEvaluator}.
	 *
	 * @param listener the listener to dispatch to.
	 * @param event an event to dispatch synchronously.
	 * @param thrownExceptions indicates if the exceptions in the event handlers should be thrown from this function,
	 *     or logged out to the agent's log.
	 * @param logger the logger to use for notifying the errors.
	 */
	def immediateDispatchTo(listener : Object, ^event : Event, thrownExceptions : boolean, logger : Logger = null) {
		assert ^event !== null
		var behaviorGuardEvaluators : Iterable<BehaviorGuardEvaluator> = null
		synchronized (this.behaviorGuardEvaluatorRegistry) {
			behaviorGuardEvaluators = this.behaviorGuardEvaluatorRegistry.getBehaviorGuardEvaluatorsFor(^event, listener)
		}
		if (behaviorGuardEvaluators !== null) {
			var behaviorsMethodsToExecute = ^event.evaluateGuards(behaviorGuardEvaluators, logger)
			behaviorsMethodsToExecute.executeBehaviorMethodsInParalellWithSynchroAtTheEnd(thrownExceptions, logger)
		}
		/*
		 * <p>If no {@code BehaviorGuardEvaluator} have been subscribed for {@code event}'s class, and {@code event} is not already a
		 * {@link DeadEvent}, it will be wrapped in a DeadEvent and reposted.
		 */
		// XXX: not in the SARL specifications. Should we fire the DeadEvent?
		/*else if (!(event instanceof DeadEvent)) {
			// the event had no subscribers and was not itself a DeadEvent
			immediateDispatch(new DeadEvent(event));
		}*/
	}

	/**
	 * Posts an event to all registered {@code BehaviorGuardEvaluator}.
	 * The dispatch of this event will be done asynchronously.
	 * This method will return successfully after the event has been posted to all {@code BehaviorGuardEvaluator}, and regardless
	 * of any exceptions thrown by {@code BehaviorGuardEvaluator}.
	 *
	 * @param event an event to dispatch asynchronously.
	 * @param logger the logger to use for notifying the errors.
	 */
	def asyncDispatch(^event : Event, logger : Logger = null) {
		assert ^event !== null
		var behaviorGuardEvaluators : Iterable<BehaviorGuardEvaluator> = null
		synchronized (this.behaviorGuardEvaluatorRegistry) {
			behaviorGuardEvaluators = this.behaviorGuardEvaluatorRegistry.getBehaviorGuardEvaluators(^event)
		}
		if (behaviorGuardEvaluators !== null) {
			var behaviorsMethodsToExecute = ^event.evaluateGuards(behaviorGuardEvaluators, logger)
			if (!behaviorsMethodsToExecute.empty) {
				behaviorsMethodsToExecute.executeAsynchronouslyBehaviorMethods(logger)
			}
		}
		// XXX: Not in the SAR specification, should we fire the DeadEvent?
			/* else if (!(event instanceof DeadEvent)) {
		 * // the event had no subscribers and was not itself a DeadEvent
		 * asyncDispatch(new DeadEvent(event));
		 * }
		 */
	}

	/**
	 * Evaluate the guard associated to the specified {@code event} and returns the list of behaviors methods that must be
	 * executed.
	 *
	 * <p>Errors are logger by the executor service. But they are not stopping the call to this function.
	 *
	 * @param event the event triggering behaviors.
	 * @param behaviorGuardEvaluators the list of class containing a {@code PerceptGuardEvaluator} method.
	 * @param logger the logger to be used.
	 * @return the collection of couple associating a object and its collection of behavior methods that must be executed.
	 * @throws InvocationTargetException - exception when you try to execute a method by reflection and this method doesn't exist.
	 */
	protected def evaluateGuards(^event : Event, behaviorGuardEvaluators : Iterable<BehaviorGuardEvaluator>,
		logger : Logger) : Collection<Runnable> {
		val behaviorsMethodsToExecute = new MultiCollection<Runnable>
		this.executor.applyBlockingConsumer(logger, behaviorGuardEvaluators) [evaluator |
				val behaviorsMethodsToExecutePerTarget = <Runnable>newLinkedList
				evaluator.evaluateGuard(^event, behaviorsMethodsToExecutePerTarget)
				synchronized (behaviorsMethodsToExecute) {
					behaviorsMethodsToExecute.addCollection(behaviorsMethodsToExecutePerTarget)
				}
		]
		return behaviorsMethodsToExecute
	}

	/**
	 * Execute every single Behaviors runnable, a dedicated thread will created by the executor local to this class and be used to
	 * execute each runnable in parallel, and this method waits until its future has been completed before leaving.
	 *
	 * <p>Errors are logged by the executor service, and are thrown by this function.
	 * 
	 * @param behaviorsMethodsToExecute the collection of Behaviors runnable that must be executed.
	 * @param thrownExceptions indicates if the exceptions in the event handlers should be thrown from this function,
	 *     or logged out to the agent's log.
	 * @param logger the logger to use for notifying the errors.
	 * @throws InterruptedException - something interrupt the waiting of the event handler terminations.
	 * @throws ExecutionException - when the event handlers cannot be called; or when one of the event handler has failed during
	 *     its run.
	 */
	protected def executeBehaviorMethodsInParalellWithSynchroAtTheEnd(behaviorsMethodsToExecute : Collection<Runnable>,
		thrownExceptions : boolean, logger : Logger) {
		this.executor.executeBlockingTasks(logger, thrownExceptions, behaviorsMethodsToExecute)
	}

	/**
	 * Execute every single Behaviors runnable, a dedicated thread will created by the executor local to this class and be used to
	 * execute each runnable in parallel.
	 * 
	 * <p>Errors are logged by the executor service. They are not thrown by this function.
	 * 
	 * @param logger the logger to use for notifying the errors.
	 * @param behaviorsMethodsToExecute the collection of Behaviors runnable that must be executed.
	 */
	protected def executeAsynchronouslyBehaviorMethods(behaviorsMethodsToExecute : Collection<Runnable>, logger : Logger) {
		for (runnable : behaviorsMethodsToExecute) {
			this.executor.executeAsap(logger, runnable)
		}
	}

}
