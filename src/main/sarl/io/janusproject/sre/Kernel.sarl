/*
 * $Id$
 *
 * SARL is an general-purpose agent programming language.
 * More details on http://www.sarl.io
 *
 * Copyright (C) 2014-2017 the original authors or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.janusproject.sre

import com.google.common.util.concurrent.Service
import com.google.inject.BindingAnnotation
import io.janusproject.sre.services.IServiceManager
import io.janusproject.sre.services.context.ContextService
import io.janusproject.sre.services.lifecycle.KernelAgentLifecycleListener
import io.janusproject.sre.services.lifecycle.LifecycleService
import io.janusproject.sre.services.logging.LoggerCreator
import io.janusproject.sre.services.logging.LoggingService
import io.sarl.lang.annotation.PrivateAPI
import io.sarl.lang.core.Agent
import io.sarl.lang.core.AgentContext
import java.lang.Thread.UncaughtExceptionHandler
import java.lang.annotation.Retention
import java.lang.annotation.Target
import java.lang.ref.WeakReference
import java.util.UUID
import java.util.concurrent.Executors
import java.util.concurrent.atomic.AtomicBoolean
import java.util.logging.Level
import java.util.logging.LogRecord
import java.util.logging.Logger
import javax.inject.Inject
import javax.inject.Singleton

/** 
 * This class represents the Kernel of the Janus platform.
 * 
 * <p><strong>The Kernel is a singleton.</strong>
 * 
 * <p>The Kernel is assimilated to an agent that is omniscient and distributed other the network. It is containing all the other
 * agents.
 * 
 * <p>To create a Kernel, you should use the function {@link #create(Module...)}.
 * 
 * @author $Author: srodriguez$
 * @author $Author: ngaud$
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
@Singleton
class Kernel {

	// value is true because the Janus kernel is running as soon as it is created. 
	val isRunning = new AtomicBoolean(true)

	val stopListener = new KernelStoppingListener(this)

	val serviceManager : IServiceManager

	val loggingService : LoggingService

	val spawnService : LifecycleService

	val contextService : ContextService

	val loggerCreator : LoggerCreator

	/** 
	 * Constructs a Janus kernel.
	 * 
	 * @param serviceManager is the instance of the service manager that must be used by the kernel.
	 *     The service manager must already have registered services inside itself.
	 * @param exceptionHandler is the handler of the uncaught exceptions.
	 * @param loggerCreator the creator of logger.
	 */
	@Inject
	new (serviceManager : IServiceManager, exceptionHandler : UncaughtExceptionHandler, loggerCreator : LoggerCreator) {
		// Initialize the fields
		this.serviceManager = serviceManager
		this.loggerCreator = loggerCreator
		this.loggingService = this.serviceManager.getService(typeof(LoggingService))
		this.spawnService = this.serviceManager.getService(typeof(LifecycleService))
		this.contextService = this.serviceManager.getService(typeof(ContextService))

		// Ensure that all the threads has a default hander.
		if (exceptionHandler !== null) {
			Thread::setDefaultUncaughtExceptionHandler(exceptionHandler)
		}

		// Listen on the kernel's events
		this.spawnService.addKernelAgentLifecycleListener(this.stopListener)

		// Start the services NOW to ensure that the default context and space
		// of the Janus agent are catched by the modules;
		this.serviceManager.startServices(getLogger)
	}

	/** Stop the kernel.
	 * You are not supposed to call this function.
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@PrivateAPI
	def stopKernel {
		val logger = getLogger
		logger.info(Messages.Kernel_0)
		this.spawnService.removeKernelAgentLifecycleListener(this.stopListener)
		this.serviceManager.stopServices(logger)
		this.isRunning.set(false)
		logger.info(Messages.Kernel_1)
	}

	/** 
	 * Replies if the kernel is running or not.
	 *
	 * <p>The kernel is running if at least one agent is alive.
	 * 
	 * @return <code>true</code> if the kernel is running; <code>false</code> otherwise.
	 */
	def isRunning : boolean {
		this.isRunning.get
	}

	/** 
	 * Replies the logger used by the kernel.
	 *
	 * <p>This function replies the logger of the logging service. If this service is down,
	 * {@code null} is replied.
	 *
	 * @return the logger of the kernel.
	 * @see #getShutdownSafeLogger()
	 */
	def getLogger : Logger {
		this.loggingService.kernelLogger
	}

	/** 
	 * Spawn an agent of the given type, and pass the parameters to its initialization function.
	 * 
	 * @param agent the type of the agent to spawn.
	 * @param params the list of the parameters to pass to the agent initialization function.
	 * @return the identifier of the agent, never <code>null</code>.
	 */
	def spawn(^agent : Class<? extends Agent>, arguments : Object*) : UUID {
		val result = this.spawnService.spawnAgent(1, null, this.contextService.rootContext, null, ^agent, arguments)
		if (result.failing) {
			throw result.error
		}
		if (result.agentSpawned) {
			var iterator = result.spawnedAgents.iterator
			if (iterator.hasNext) {
				return iterator.next
			}
		}
		return null
	}

	/** 
	 * Spawn agents of the given type, and pass the parameters to its initialization function.
	 * 
	 * @param nbAgents the number of agents to spawn.
	 * @param agent the type of the agents to spawn.
	 * @param params the list of the parameters to pass to the agent initialization function.
	 * @return the identifiers of the agents, never <code>null</code>.
	 */
	def spawn(nbAgents : int, ^agent : Class<? extends Agent>, params : Object*) : Iterable<UUID> {
		var result = this.spawnService.spawnAgent(nbAgents, null, this.contextService.rootContext, null, ^agent, params)
		if (result.failing) {
			var exception = result.error
			this.loggingService.kernelLogger.log(Level::SEVERE, exception.localizedMessage, exception)
		}
		return result.spawnedAgents
	}

	/** 
	 * Spawn an agent of the given type, and pass the parameters to its initialization function.
	 * 
	 * @param agentID the identifier of the agent to spawn. If <code>null</code> the identifier is randomly selected.
	 * @param agent the type of the agent to spawn.
	 * @param params the list of the parameters to pass to the agent initialization function.
	 * @return the identifier of the agent, never <code>null</code>.
	 */
	def spawn(agentID : UUID, ^agent : Class<? extends Agent>, params : Object*) : UUID {
		val result = this.spawnService.spawnAgent(1, null, this.contextService.rootContext, agentID, ^agent, params)
		if (result.failing) {
			throw result.error
		}
		if (result.agentSpawned) {
			var iterator = result.spawnedAgents.iterator
			if (iterator.hasNext) {
				return iterator.next
			}
		}
		return null
	}

	/** 
	 * Replies a kernel service that is alive.
	 * 
	 * @param <S> - type of the type to reply.
	 * @param type type of the type to reply.
	 * @return the service, or <code>null</code>.
	 */
	def getService(type : Class<S>) : S with S extends Service {
		this.serviceManager.getService(type)
	}

	/** 
	 * Replies the Janus context of the kernel.
	 * 
	 * @return the context for the kernel.
	 */
	protected def getRootContext : AgentContext {
		this.contextService.rootContext
	}

	/** 
	 * Listener on platform events.
	 * 
	 * @author $Author: sgalland$
	 * @version $FullVersion$
	 * @mavengroupid $GroupId$
	 * @mavenartifactid $ArtifactId$
	 */
	private static class KernelStoppingListener implements KernelAgentLifecycleListener, Runnable, UncaughtExceptionHandler {

		val kernel : WeakReference<Kernel>

		val stopProcessRunning = new AtomicBoolean(false)

		new (kernel : Kernel) {
			this.kernel = new WeakReference(kernel)
		}

		override kernelAgentDestroyed {
			if (!this.stopProcessRunning.getAndSet(true)) {
				// CAUTION: EXECUTE THE STOP FUNCTION IN A THREAD THAT
				// IS INDEPENDENT TO THE ONES FROM THE EXECUTORS
				// CREATED BY THE EXECUTORSERVICE.
				// THIS AVOID THE STOP FUNCTION TO BE INTERRUPTED
				// BECAUSE THE EXECUTORSERVICE WAS SHUTTED DOWN.
				val thread = Executors::defaultThreadFactory().newThread(this)
				thread.name = "Janus kernel shutdown" // $NON-NLS-1$
				thread.daemon = false
				thread.uncaughtExceptionHandler = this
				thread.start
			}
		}

		override run {
			val kern = this.kernel.get
			val logger = kern.logger
			logger.info(Messages.Kernel_0)
			kern.serviceManager.stopServices(logger)
			logger.info(Messages.Kernel_1)
			kern.isRunning.set(false)
		}
		
		override uncaughtException(thread : Thread, exception : Throwable) {
			assert thread !== null;
			assert exception !== null;
			val record = new LogRecord(Level::SEVERE, exception.localizedMessage)
			record.thrown = exception
			val elt = exception.stackTrace.get(0)
			assert elt !== null
			record.sourceClassName = elt.className
			record.sourceMethodName = elt.methodName
			val logger = this.kernel.get.logger
			logger.log(record)
		}
		
	}

}

/** 
 * Annotation for injection of the kernel.
 * 
 * @author $Author: srodriguez$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
@BindingAnnotation
@Target(#[ FIELD, PARAMETER, METHOD ])
@Retention(RUNTIME)
annotation KernelScope {
	//
}
