/*
 * $Id$
 *
 * SARL is an general-purpose agent programming language.
 * More details on http://www.sarl.io
 *
 * Copyright (C) 2014-2019 the original authors or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.sarl.sre.services.namespace

import io.sarl.core.Behaviors
import io.sarl.lang.annotation.PrivateAPI
import io.sarl.lang.core.Agent
import io.sarl.lang.core.Behavior
import io.sarl.lang.core.SREutils
import io.sarl.lang.core.Skill
import io.sarl.lang.core.Space
import io.sarl.sre.naming.AgentName
import io.sarl.sre.naming.BehaviorName
import io.sarl.sre.naming.ContextName
import io.sarl.sre.naming.SarlName
import io.sarl.sre.naming.SkillName
import io.sarl.sre.naming.SpaceName
import io.sarl.sre.services.context.Context
import io.sarl.sre.services.context.ContextService
import io.sarl.sre.spaces.SpaceWithParticipants
import java.util.UUID
import javax.inject.Inject
import org.eclipse.xtend.lib.annotations.Accessors
import io.sarl.lang.core.UnimplementedCapacityException

/** 
 * Implementation based on injection of a service that manages name spaces into the SRE.
 * 
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 * @since 0.10
 */
class InjectionBasedNamespaceService extends AbstractNamespaceService {

	@Accessors(PROTECTED_GETTER)
	var contextService : ContextService

	/** Change the context service. */
	@Inject
	def setContextService(service : ContextService) {
		this.contextService = service
	}

	protected override findContext(name : ContextName) : Context {
		var id = name.contextId
		if (id !== null) {
			var ctx = this.contextService.getContext(id)
			if (ctx !== null) {
				name.associatedContext = ctx
				return ctx
			}
		}
		return null
	}

	protected override findSpace(name : SpaceName) : Space {
		var contextId = name.contextId
		if (contextId !== null) {
			var spaceId = name.spaceId
			if (spaceId !== null) {
				var ctx = this.contextService.getContext(contextId)
				if (ctx !== null) {
					var spc = ctx.getSpace(spaceId)
					if (spc !== null) {
						name.associatedSpace = spc
						return spc
					}
				}
			}
		}
		return null
	}

	/** Find the agent.
	 */
	@SuppressWarnings("use_reserved_sarl_annotation")
	@PrivateAPI(isCallerOnly = true)
	protected def findAgent(contextId : UUID, spaceId : UUID, agentId : UUID) : Agent {
		if (agentId !== null) {
			var cid = contextId
			var ctx : Context
			if (cid === null) {
				ctx = this.contextService.rootContext
			} else {
				ctx = this.contextService.getContext(cid)
				if (ctx === null) {
					return null
				}
			}
			assert ctx !== null
			var sid = spaceId
			var ^space : Space
			if (sid === null) {
				^space = ctx.defaultSpace
			} else {
				^space = ctx.getSpace(sid)
				if (^space === null) {
					return null
				}
			}
			if (^space instanceof SpaceWithParticipants) {
				var participantMap = ^space.internalParticipantStructure
				var participant = participantMap.get(agentId)
				if (participant !== null) {
					var listener = participant.participant
					return listener.ownerInstance
				}
			}
		}
		return null
	}

	protected override findAgent(name : AgentName) : Agent {
		var ^agent = findAgent(name.contextId, name.spaceId, name.agentId)
		if (^agent !== null) {
			name.associatedAgent = ^agent
		}
		return ^agent
	}

	@SuppressWarnings("use_reserved_sarl_annotation")
	@PrivateAPI(isCallerOnly = true)
	protected override findSkill(name : SkillName) : Skill {
		var ^capacity = name.^capacity
		if (^capacity !== null) {
			var ^agent = findAgent(name.contextId, name.spaceId, name.agentId)
			if (^agent !== null) {
				try {
					var ^skill = SREutils::getInternalSkill(^agent, ^capacity)
					if (^skill instanceof Skill) {
						name.associatedSkill = ^skill
						return ^skill
					}
				} catch (ex : UnimplementedCapacityException) {
					//
				}
			}
		}
		return null
	}

	@SuppressWarnings("use_reserved_sarl_annotation")
	@PrivateAPI(isCallerOnly = true)
	protected override findBehavior(name : BehaviorName) : Behavior {
		var behaviorType = name.behaviorType
		if (behaviorType !== null) {
			var ^agent = findAgent(name.contextId, name.spaceId, name.agentId)
			if (^agent !== null) {
				var behaviors = SREutils::getInternalSkill(^agent, typeof(Behaviors))
				var index = 0
				for (beh : behaviors.registeredBehaviors) {
					if (behaviorType.isInstance(beh)) {
						if (name.behaviorIndex < 0 || name.behaviorIndex === index) {
							name.associatedBehavior = beh
							return beh
						}
						index++
					}
				}
			}
		}
		return null
	}

	def findName(object : Object) : SarlName {
		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}
	
}
