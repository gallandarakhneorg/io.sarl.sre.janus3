/*
 * $Id$
 *
 * SARL is an general-purpose agent programming language.
 * More details on http://www.sarl.io
 *
 * Copyright (C) 2014-2018 the original authors or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.sarl.sre.services.executor

import io.bootique.config.ConfigurationFactory
import io.sarl.sre.boot.factories.ExecutorFactory
import io.sarl.sre.services.PreReleasableService
import java.lang.Thread.UncaughtExceptionHandler
import java.lang.ref.WeakReference
import java.util.Collection
import java.util.concurrent.Callable
import java.util.concurrent.Future
import java.util.concurrent.ScheduledExecutorService
import java.util.concurrent.ScheduledFuture
import java.util.concurrent.ThreadPoolExecutor
import java.util.concurrent.TimeUnit
import java.util.logging.Logger
import javax.inject.Inject
import javax.inject.Singleton

/** 
 * Service that executes the tasks asynchronously (in threads) with the JRE executor service.
 * 
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
@Singleton
class JreExecutorService extends AbstractExecutorService implements PreReleasableService {

	var jreSchedules : ScheduledExecutorService

	var uncaughtExceptionHandler : UncaughtExceptionHandler

	var purgeTask : ScheduledFuture<?>

	var configuration : ExecutorFactory

	/** 
	 * Change the JRE service for scheduled tasks.
	 * 
	 * @param service the JRE service.
	 */
	@Inject
	def setScheduledExecutorService(service : ScheduledExecutorService) {
		this.jreSchedules = service
	}

	/**
	 * Replies the JRE service for scheduled tasks.
	 * 
	 * @param the JRE service.
	 */
	def getScheduledExecutorService : ScheduledExecutorService {
		this.jreSchedules
	}

	/** 
	 * Change the default exception handler.
	 * 
	 * @param handler the default exception handler.
	 */
	@Inject
	def setUncaughtExceptionHandler(handler : UncaughtExceptionHandler) {
		this.uncaughtExceptionHandler = handler
	}
	/** 
	 * Replies the default exception handler.
	 * 
	 * @return the default exception handler.
	 */
	def getUncaughtExceptionHandler : UncaughtExceptionHandler {
		this.uncaughtExceptionHandler
	}

	/** 
	 * Change the bootique configuration factory.
	 * 
	 * @param factory the configuration factory.
	 */
	@Inject
	def setConfigurationFactory(factory : ConfigurationFactory) {
		this.configuration = ExecutorFactory::getConfigurationFactory(factory)
	}

	/** 
	 * Replies the configuration factory.
	 * 
	 * @param the configuration factory.
	 */
	def getConfigurationFactory : ExecutorFactory {
		this.configuration
	}

	protected def onStart {
		assert this.jreSchedules !== null
		var uncaughtHandler = getUncaughtExceptionHandler
		if (uncaughtHandler !== null) {
			Thread::setDefaultUncaughtExceptionHandler(uncaughtHandler)
		}
		// Launch a periodic task that is purging the executor pools.
		var es = executorService
		var ses = scheduledExecutorService
		if (es instanceof ThreadPoolExecutor || ses instanceof ThreadPoolExecutor) {
			val delay = configurationFactory.timeout * 2
			this.purgeTask = scheduledExecutorService.scheduleWithFixedDelay(new Purger(this),
				delay, delay, TimeUnit::SECONDS)
		}
	}

	override onPreStop {
		shutdown
	}

	protected def onStop {
		shutdown
	}

	private def shutdown {
		var pt = this.purgeTask
		this.purgeTask = null
		if (pt !== null) {
			pt.cancel(true)
		}
		var je = getExecutorService
		try {
			je.shutdownNow
		} catch (e : Throwable) {
		}
		var js = scheduledExecutorService
		try {
			js.shutdownNow
		} catch (e : InterruptedException) {
		}
	}

	/** Create a task with the given runnable.
	 *
	 * @param runnable the runnable.
	 * @param logger the logger to use.
	 * @return the task.
	 */
	protected def wrap(runnable : Runnable, logger : Logger) : SreRunnable {
		if (runnable instanceof SreRunnable) {
			return runnable
		}
		return new SreRunnable(runnable, logger)
	}

	/** Create a task with the given callable.
	 *
	 * @param <T> the type of the returned value.
	 * @param callable the callable.
	 * @param logger the logger to use.
	 * @return the task.
	 */
	protected def wrap(callable : Callable<T>, logger : Logger) : SreCallable<T> with T {
		if (callable instanceof SreCallable<?>) {
			return callable as SreCallable<T>
		}
		return new SreCallable(callable, logger)
	}

	def executeBlockingTasks(logger : Logger, thrownExceptions : boolean = false,
		tasks : Collection<Runnable>) {
		tasks.executeInThreadsAndWait(thrownExceptions) [catchErrors, runnable |
			if (catchErrors) runnable.wrap(logger) else runnable.wrap(null)
		]
	}

	def executeBlockingTask(logger : Logger,
		nbExecutions : int, runGroupSize : int, task : Runnable) : int {
		executeInThreadsAndWait(task.wrap(logger), nbExecutions, runGroupSize)
	}

	def executeAsap(logger : Logger, task : Runnable) : Future<?> {
		executorService.submit(task.wrap(logger))
	}

	def executeAsap(logger : Logger, result : T, task : Runnable) : Future<T> with T {
		executorService.submit(task.wrap(logger), result)
	}

	def executeAsap(logger : Logger, task : Callable<T>) : Future<T> with T {
		executorService.submit(task.wrap(logger))
	}

	def schedule(logger : Logger, delay : long, unit : TimeUnit, command : Runnable) : ScheduledFuture<?> {
		scheduledExecutorService.schedule(command.wrap(logger), delay, unit)
	}

	def schedule(logger : Logger, delay : long, unit : TimeUnit, command : Callable<T>) : ScheduledFuture<T> with T {
		scheduledExecutorService.schedule(command.wrap(logger), delay, unit)
	}

	def scheduleAtFixedRate(logger : Logger, initialDelay : long, period : long,
		unit : TimeUnit, command : Runnable) : ScheduledFuture<?> {
		scheduledExecutorService.scheduleAtFixedRate(command.wrap(logger), initialDelay, period, unit)
	}

	def scheduleWithFixedDelay(logger : Logger, initialDelay : long, delay : long,
		unit : TimeUnit, command : Runnable) : ScheduledFuture<?> {
		scheduledExecutorService.scheduleWithFixedDelay(command.wrap(logger), initialDelay, delay, unit)
	}

	def purge {
		var es = executorService
		if (es instanceof ThreadPoolExecutor) {
			es.purge
		}
		var ses = scheduledExecutorService
		if (ses instanceof ThreadPoolExecutor) {
			ses.purge
		}
	}

	/**
	 * Task that is purging the thread pools.
	 *
	 * @author $Author: sgalland$
	 * @version $FullVersion$
	 * @mavengroupid $GroupId$
	 * @mavenartifactid $ArtifactId$
	 */
	private static class Purger implements Runnable {

		val owner : WeakReference<ExecutorService>
	
		var oldThreadName : String

		new (owner : ExecutorService) {
			this.owner = new WeakReference(owner)
		}
	
		private def setName : boolean {
			if (!this.oldThreadName.nullOrEmpty) {
				return false
			}
			val t = Thread::currentThread
			this.oldThreadName = t.getName
			t.name = toString
			return true
		}

		private def restoreName : boolean {
			if (this.oldThreadName.nullOrEmpty) {
				return false
			}
			val t = Thread::currentThread
			t.name = this.oldThreadName
			this.oldThreadName = null
			return true
		}

		override run {
			assert setName
			try {
				val owner = this.owner.get
				if (owner !== null) {
					owner.purge
				}
			} finally {
				assert restoreName
			}
		}

		def toString : String {
			"SARL Thread Purger"
		}

	}

}
