/* 
 * $Id$
 * 
 * SARL is an general-purpose agent programming language.
 * More details on http://www.sarl.io
 * 
 * Copyright (C) 2014-2018 the original authors or authors.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.sarl.sre.boot.adhoc

import com.google.common.base.Strings
import com.google.inject.Guice
import com.google.inject.Module
import io.sarl.bootstrap.SRE
import io.sarl.lang.SARLVersion
import io.sarl.lang.core.Agent
import io.sarl.lang.core.AgentContext
import io.sarl.sre.JanusConfig
import io.sarl.sre.JanusVersion
import io.sarl.sre.Kernel
import io.sarl.sre.services.executor.EarlyExitException
import io.sarl.sre.services.executor.ExecutorService
import io.sarl.sre.services.logging.LoggerCreator
import java.io.File
import java.io.PrintStream
import java.io.PrintWriter
import java.lang.reflect.Array
import java.net.MalformedURLException
import java.net.URL
import java.net.URLClassLoader
import java.text.MessageFormat
import java.util.ArrayList
import java.util.Arrays
import java.util.Properties
import java.util.UUID
import java.util.logging.Logger
import java.util.regex.Pattern
import org.apache.commons.cli.DefaultParser
import org.apache.commons.cli.HelpFormatter
import org.apache.commons.cli.Option
import org.apache.commons.cli.Options
import org.arakhne.afc.vmutil.FileSystem
import org.arakhne.afc.vmutil.URISchemeType

import static io.sarl.bootstrap.SRE.*

/** 
 * This is the class that permits to boot the Janus platform.
 * 
 * <p>This class provides the "main" function for the platform. The list of the parameters is composed of a list of options, the
 * classname of an agent to launch, and the parameters to pass to the launched agent.
 * 
 * <p>The supported options may be obtain by passing no parameter, or the option <code>-h</code>.
 * 
 * <p>Example of Janus launching with Maven:
 * <pre>
 * <code>mvn exec:java
 * -Dexec.mainClass="io.janusproject.Boot"
 * -Dexec.args="my.Agent"</code>
 * </pre>
 * 
 * <p>Example of Janus launching from the CLI (only with the Jar file that is containing all the jar dependencies):
 * <pre>
 * <code>java -jar janus-with-dependencies.jar my.Agent</code>
 * </pre>
 * 
 * @author $Author: srodriguez$
 * @author $Author: sgalland$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 */
class JanusBooter implements Booter {

			/** Short command-line option for "embedded".
		 */
	public static val CLI_OPTION_EMBEDDED_SHORT = "e"

	/** Long command-line option for "embedded".
	 */
	public static val CLI_OPTION_EMBEDDED_LONG = "embedded"

	/** Short command-line option for "boot agent id".
	 */
	public static val CLI_OPTION_BOOTID_SHORT = "B"

	/** Long command-line option for "boot agent id".
	 */
	public static val CLI_OPTION_BOOTID_LONG = "bootid"

	/** Short command-line option for "random id".
	 */
	public static val CLI_OPTION_RANDOMID_SHORT = "R"

	/** Long command-line option for "random id".
	 */
	public static val CLI_OPTION_RANDOMID_LONG = "randomid"

	/** Short command-line option for "Janus world id".
	 */
	public static val CLI_OPTION_WORLDID_SHORT = "W"

	/** Long command-line option for "Janus world id".
	 */
	public static val CLI_OPTION_WORLDID_LONG = "worldid"

	/** Short command-line option for "file".
	 */
	public static val CLI_OPTION_FILE_SHORT = "f"

	/** Long command-line option for "file".
	 */
	public static val CLI_OPTION_FILE_LONG = "file"

	/** Short command-line option for "help".
	 */
	public static val CLI_OPTION_HELP_SHORT = "h"

	/** Long command-line option for "help".
	 */
	public static val CLI_OPTION_HELP_LONG = "help"

	/** Long command-line option for "nologo".
	 */
	public static val CLI_OPTION_NOLOGO_LONG = "nologo"

	/** Short command-line option for "be quiet".
	 */
	public static val CLI_OPTION_QUIET_SHORT = "q"

	/** Long command-line option for "be quiet".
	 */
	public static val CLI_OPTION_QUIET_LONG = "quiet"

	/** Short command-line option for "be more verbose".
	 */
	public static val CLI_OPTION_VERBOSE_SHORT = "v"

	/** Long command-line option for "be more verbose".
	 */
	public static val CLI_OPTION_VERBOSE_LONG = "verbose"

	/** Long command-line option for "display the version".
	 */
	public static val CLI_OPTION_VERSION = "version"

	/** Short command-line option for "change log level".
	 */
	public static val CLI_OPTION_LOG_SHORT = "l"

	/** Long command-line option for "change log level".
	 */
	public static val CLI_OPTION_LOG_LONG = "log"

	/** Short command-line option for "env. variable definition".
	 */
	public static val CLI_OPTION_DEFINE_SHORT = "D"

	/** Long command-line option for "env. variable definition".
	 */
	public static val CLI_OPTION_DEFINE_LONG = "define"

	/** Short command-line option for "show defaults".
	 */
	public static val CLI_OPTION_SHOWDEFAULTS_SHORT = "s"

	/** Long command-line option for "show defaults".
	 */
	public static val CLI_OPTION_SHOWDEFAULTS_LONG = "showdefaults"

	/** Short command-line option for "show the classpath".
	 */
	public static val CLI_OPTION_SHOWCLASSPATH = "showclasspath"

	/** Short command-line option for "show CLI arguments".
	 */
	public static val CLI_OPTION_SHOWCLIARGUMENTS_LONG = "cli"

	/** Short command-line option for "classpath".
	 */
	public static val CLI_OPTION_CLASSPATH_SHORT = "cp"

	/** Long command-line option for "classpath".
	 */
	public static val CLI_OPTION_CLASSPATH_LONG = "classpath"

	static val ERROR_EXIT_CODE = 255

	var applicationExiter : Runnable

	var bootConsoleLogger : PrintStream

	var bootAgentId : UUID

	volatile var kernel : Kernel

	val loggerCreator = new LoggerCreator

	var dynamicClassLoader : URLClassLoader

	override parseCommandLine(args : String[]) : String[] {
		val parser = new DefaultParser
		try {
			val cmd = parser.parse(this.options, args, false)

			var noLogo = false
			var embedded = false
			var verbose = LoggerCreator::toInt(JanusConfig::VERBOSE_LEVEL_VALUE)
			val optIterator = cmd.iterator
			var userClasspath = false

			while (optIterator.hasNext) {
				var opt = optIterator.next
				var optName = opt.longOpt
				if (optName.nullOrEmpty) {
					optName = opt.opt
				}
				switch (optName) {
					case CLI_OPTION_HELP_LONG: {
						showHelp
						return null
					}
					case CLI_OPTION_VERSION: {
						showVersion
						return null
					}
					case CLI_OPTION_SHOWDEFAULTS_LONG: {
						showDefaults
						return null
					}
					case CLI_OPTION_SHOWCLASSPATH: {
						setDefaultClasspath(userClasspath)
						showClasspath
						return null
					}
					case CLI_OPTION_SHOWCLIARGUMENTS_LONG: {
						showCommandLineArguments(args)
						return null;
					}
					case CLI_OPTION_FILE_LONG: {
						val rawFilename = opt.value
						if (rawFilename.nullOrEmpty) {
							showHelp
							return null
						}
						val file = new File(rawFilename)
						if (!file.canRead) {
							showError(MessageFormat::format(Messages::Boot_0, rawFilename), null);
							return null
						}
						JanusConfig::setPropertiesFrom(file)
					}
					case CLI_OPTION_CLASSPATH_LONG: {
						userClasspath = true
						opt.value.addToSystemClasspath
					}
					case CLI_OPTION_RANDOMID_LONG: {
						setRandomContextUUID
					}
					case CLI_OPTION_BOOTID_LONG: {
						setBootAgentTypeContextUUID
					}
					case CLI_OPTION_WORLDID_LONG: {
						setDefaultContextUUID
					}
					case CLI_OPTION_DEFINE_LONG: {
						val name = opt.getValue(0)
						if (!name.nullOrEmpty) {
							JanusConfig::setProperty(name, Strings::emptyToNull(opt.getValue(1)))
						}
					}
					case CLI_OPTION_LOG_LONG: {
						verbose = Math::max(LoggerCreator::toInt(opt.value), 0)
					}
					case CLI_OPTION_QUIET_LONG: {
						if (verbose > 0) {
							verbose--
						}
					}
					case CLI_OPTION_VERBOSE_LONG: {
						verbose++
					}
					case CLI_OPTION_NOLOGO_LONG: {
						noLogo = true
					}
					case CLI_OPTION_EMBEDDED_LONG: {
						embedded = true;
					}
				}
			}

			setDefaultClasspath(userClasspath)

			// Show the help when there is no argument.
			if (cmd.args.length == 0) {
				showHelp
				return null
			}

			// Change the verbosity
			this.verboseLevel = verbose
			// Do nothing at exit
			if (embedded) {
				this.exiter = [ExecutorService::neverReturn]
			}
			// Show the Janus logo?
			if (noLogo || verbose == 0) {
				JanusConfig::setProperty(JanusConfig::JANUS_LOGO_SHOW_NAME, Boolean::FALSE.toString)
			}
			return cmd.args
		} catch (e : Throwable) {
			showError(e.localizedMessage, e)
			// Event if showError never returns, add the return statement for
			// avoiding compilation error.
			return null
		}
	}

	/** 
	 * Replies the current class loader.
	 * 
	 * @return the current class loader.
	 * @since 0.7
	 */
	def getAgentClassLoader : URLClassLoader {
		if (this.dynamicClassLoader === null) {
			val cl = ClassLoader::systemClassLoader
			if (cl instanceof URLClassLoader) {
				this.dynamicClassLoader = cl
			} else {
				this.dynamicClassLoader = URLClassLoader.newInstance(Array::newInstance(typeof(URL), 0) as URL[], cl)
			}
		}
		return this.dynamicClassLoader
	}

	/** 
	 * Replies the current class path.
	 * 
	 * @return the current class path.
	 * @since 0.7
	 */
	def getCurrentClasspath : String {
		val path = new StringBuilder
		for (url : agentClassLoader.URLs) {
			if (path.length() > 0) {
				path.append(File::pathSeparator)
			}
			val file = FileSystem::convertURLToFile(url)
			if (file !== null) {
				path.append(file.absolutePath)
			}
		}
		return path.toString
	}

	private def setDefaultClasspath(hasUserClasspath : boolean) {
		if (!hasUserClasspath) {
			// Force the current directory to be inside the class path (since 0.7)
			var path = System::getProperty("user.dir")
			if (!path.endsWith(File::separator)) {
				path = path + File::separator
			}
			addToSystemClasspath(path)
		}
	}

	def addToSystemClasspath(entries : String) {
		if (!entries.nullOrEmpty) {
			val cp = new ArrayList
			val individualEntries = entries.split(Pattern.quote(File.pathSeparator))
			for (entry : individualEntries) {
				if (!entry.isNullOrEmpty) {
					var url = FileSystem::convertStringToURL(entry, false)
					if (url !== null) {
						// Normalize the folder name in order to have a "/" at the end of the name.
						// Without this "/" the class loader cannot find the resources.
						if (URISchemeType::FILE.isURL(url)) {
							val file = FileSystem::convertURLToFile(url)
							if (file !== null) {
								try {
									var ext = FileSystem::extension(file)?.toLowerCase
									if (file.isDirectory || (ext != ".jar" && ext != ".zip")) {
										url = new URL(URISchemeType::FILE.name, "", file.absolutePath + "/")
									}
								} catch (e : MalformedURLException) {
								}
							}
						}
						cp += url
					}
				}
			}
			val newcp = Array::newInstance(typeof(URL), cp.size) as URL[] 
			cp.toArray(newcp)
			this.dynamicClassLoader = URLClassLoader.newInstance(newcp, agentClassLoader);
		}
	}

	private def loadAgentClass(fullyQualifiedName : String) : Class<? extends Agent> {
		var type : Class<?> 
		try {
			type = agentClassLoader.loadClass(fullyQualifiedName)
		} catch (e : Exception) {
			showError(MessageFormat::format(
					Messages::Boot_1,
					fullyQualifiedName, getCurrentClasspath),
					e);
			// Event if showError never returns, add the return statement for
			// avoiding compilation error.
			return null
		}
		// The following test is needed because the
		// cast to Class<? extends Agent> is not checking
		// the Agent type (it is a generic type, not
		// tested at runtime).
		if (typeof(Agent).isAssignableFrom(type)) {
			return type.asSubclass(typeof(Agent))
		}

		showError(MessageFormat::format(Messages::Boot_2, fullyQualifiedName), null);
		// Event if showError never returns, add the return statement for
		// avoiding compilation error.
		return null
	}

	@SuppressWarnings("discouraged_reference")
	override getConsoleLogger : PrintStream {
		this.bootConsoleLogger ?: System::out
	}

	override setConsoleLogger(stream : PrintStream) {
		this.bootConsoleLogger = stream
	}

	protected def getLogger : Logger {
		this.loggerCreator.createConsoleLogger(this.class.name, this.consoleLogger)
	}
	
	override getOptions : Options {
		var options = new Options

		options.addOption(CLI_OPTION_CLASSPATH_SHORT, CLI_OPTION_CLASSPATH_LONG, true,
				Messages::Boot_24)

		options.addOption(CLI_OPTION_EMBEDDED_SHORT, CLI_OPTION_EMBEDDED_LONG, false,
				Messages::Boot_5)

		options.addOption(CLI_OPTION_BOOTID_SHORT, CLI_OPTION_BOOTID_LONG, false,
				MessageFormat::format(Messages::Boot_6,
						JanusConfig::BOOT_DEFAULT_CONTEXT_ID_NAME, JanusConfig::RANDOM_DEFAULT_CONTEXT_ID_NAME))

		options.addOption(CLI_OPTION_FILE_SHORT, CLI_OPTION_FILE_LONG, true,
				Messages::Boot_7)

		options.addOption(CLI_OPTION_HELP_SHORT, CLI_OPTION_HELP_LONG, false,
				Messages::Boot_8)

		options.addOption(null, CLI_OPTION_NOLOGO_LONG, false,
				Messages::Boot_9)

		options.addOption(CLI_OPTION_QUIET_SHORT, CLI_OPTION_QUIET_LONG, false,
				Messages::Boot_11)

		options.addOption(CLI_OPTION_RANDOMID_SHORT, CLI_OPTION_RANDOMID_LONG, false,
				MessageFormat::format(Messages::Boot_12,
						JanusConfig::BOOT_DEFAULT_CONTEXT_ID_NAME, JanusConfig::RANDOM_DEFAULT_CONTEXT_ID_NAME))

		options.addOption(CLI_OPTION_SHOWDEFAULTS_SHORT, CLI_OPTION_SHOWDEFAULTS_LONG, false,
				Messages::Boot_13)

		options.addOption(CLI_OPTION_SHOWCLASSPATH, false,
				Messages::Boot_23)

		options.addOption(null, CLI_OPTION_SHOWCLIARGUMENTS_LONG, false,
				Messages::Boot_14)

		options.addOption(CLI_OPTION_VERBOSE_SHORT, CLI_OPTION_VERBOSE_LONG, false,
				Messages::Boot_15)

		options.addOption(CLI_OPTION_VERSION, false,
				Messages::Boot_25)

		options.addOption(CLI_OPTION_WORLDID_SHORT, CLI_OPTION_WORLDID_LONG, false,
				MessageFormat::format(Messages::Boot_16,
						JanusConfig::BOOT_DEFAULT_CONTEXT_ID_NAME, JanusConfig::RANDOM_DEFAULT_CONTEXT_ID_NAME))
						
		val b = new StringBuilder
		var level = 0
		for (logLevel : LoggerCreator::levelStrings) {
			if (b.length() > 0) {
				b.append(", ")
			}
			b.append(logLevel)
			b.append(" (")
			b.append(level)
			b.append(")")
			level++
		}
		var opt = new Option(CLI_OPTION_LOG_SHORT, CLI_OPTION_LOG_LONG, true,
				MessageFormat::format(Messages::Boot_17, JanusConfig::VERBOSE_LEVEL_VALUE, b))
		opt.args = 1
		options.addOption(opt)
		opt = new Option(CLI_OPTION_DEFINE_SHORT, CLI_OPTION_DEFINE_LONG, true, Messages::Boot_18)
		opt.args = 2
		opt.valueSeparator = '='
		opt.argName = Messages::Boot_19
		options.addOption(opt)
		return options
	}

	/**
	 * Show an error message, and exit.
	 *
	 * <p>This function never returns.
	 *
	 * @param message the description of the error.
	 * @param exception the cause of the error.
	 */
	def showError(message : String, exception : Throwable) {
		val logger = new PrintWriter(this.consoleLogger)
		try {
			if (!message.isNullOrEmpty) {
				logger.println(message)
			} else if (exception !== null) {
				exception.printStackTrace(logger)
			}
			logger.println
			logger.flush
			logger.showHelp
		} finally {
			logger.close
		}
	}

	/** 
	 * Show the help message on the standard console. This function never returns.
	 */
	override showHelp(logger : PrintWriter = null) : void {
		var output = logger ?: new PrintWriter(this.consoleLogger)
		try {
			val formatter = new HelpFormatter
			formatter.printHelp(output, HelpFormatter::DEFAULT_WIDTH,
					this.programName + " " //$NON-NLS-1$
					+ Messages::Boot_20,
					"", //$NON-NLS-1$
			this.options, HelpFormatter::DEFAULT_LEFT_PAD, HelpFormatter::DEFAULT_DESC_PAD, "")
			output.flush
		} finally {
			output.close
		}
		getExiter.run
	}

	override getProgramName : String {
		var programName = JanusConfig::getSystemProperty(JanusConfig::JANUS_PROGRAM_NAME, null)
		if (programName.nullOrEmpty) {
			programName = JanusConfig::JANUS_PROGRAM_NAME_VALUE
		}
		return programName
	}

	override showDefaults {
		val defaultValues = new Properties
		JanusConfig::getDefaultValues(defaultValues)
		val os = this.consoleLogger
		try {
			defaultValues.storeToXML(os, null)
			os.flush
		} catch (e : Throwable) {
			e.printStackTrace(os)
		} finally {
			os.close
		}
		getExiter.run
	}

	override showClasspath {
		val cp = getCurrentClasspath
		if (!cp.nullOrEmpty) {
			val ps = this.consoleLogger
			try {
				for (entry : cp.split(Pattern::quote(File::pathSeparator))) {
					ps.println(entry)
				}
				ps.flush
			} finally {
				ps.close
			}
		}
		getExiter.run
	}

	override showVersion {
		val logger = new PrintWriter(this.consoleLogger)
		try {
			logger.println(MessageFormat::format(Messages::Boot_26, JanusVersion::JANUS_RELEASE_VERSION))
			logger.println(MessageFormat::format(Messages::Boot_27, SARLVersion::SPECIFICATION_RELEASE_VERSION_STRING))
			logger.flush();
		} finally {
			logger.close
		}
		getExiter.run
	}

	/**
	 * Show the command line arguments. This function never returns.
	 *
	 * @param args the command line arguments.
	 */
	def showCommandLineArguments(args : String[]) {
		val os = this.consoleLogger
		try {
			for (var i = 0; i < args.length; i++) {
				os.println(i + ": " + args.get(i))
			}
			os.flush
		} catch (e : Throwable) {
			e.printStackTrace(os)
		} finally {
			os.close
		}
		getExiter.run
	}

	override showJanusLogo {
		this.consoleLogger.println(Messages::Boot_21)
	}

	override setRandomContextUUID {
		System::setProperty(JanusConfig::BOOT_DEFAULT_CONTEXT_ID_NAME, Boolean::FALSE.toString)
		System::setProperty(JanusConfig::RANDOM_DEFAULT_CONTEXT_ID_NAME, Boolean::TRUE.toString)
	}

	override setBootAgentTypeContextUUID {
		System::setProperty(JanusConfig::BOOT_DEFAULT_CONTEXT_ID_NAME, Boolean::TRUE.toString)
		System::setProperty(JanusConfig::RANDOM_DEFAULT_CONTEXT_ID_NAME, Boolean::FALSE.toString)
	}

	override setDefaultContextUUID {
		System::setProperty(JanusConfig::BOOT_DEFAULT_CONTEXT_ID_NAME, Boolean::FALSE.toString)
		System::setProperty(JanusConfig::RANDOM_DEFAULT_CONTEXT_ID_NAME, Boolean::FALSE.toString)
	}

	override setVerboseLevel(level : int) {
		System::setProperty(JanusConfig::VERBOSE_LEVEL_NAME, Integer::toString(level))
	}

	override getBootAgentIdentifier : UUID {
		var aid = this.bootAgentId
		if (aid === null) {
			val id = JanusConfig::getSystemProperty(JanusConfig::BOOT_AGENT_ID)
			if (!id.nullOrEmpty) {
				try {
					aid = UUID::fromString(id)
				} catch (exception : Throwable) {
					//
				}
			}
			this.bootAgentId = aid
		}
		return aid
	}

	def prepareJanusStart(agentType : Class<? extends Agent>) {
		// Set the boot agent class name
		System::setProperty(JanusConfig::BOOT_AGENT, agentType.name)
	}

	override startJanus(agentCls : Class<? extends Agent>, params : Object*) : Kernel {
		startJanusWithModuleType(null, agentCls, params)
	}

	override startJanusWithModuleType(platformModule : Class<? extends Module>, agentCls : Class<? extends Agent>,
		params : Object*) : Kernel {
		var startupModule = platformModule
		if (startupModule === null) {
			startupModule = JanusConfig::getSystemPropertyAsClass(typeof(Module), JanusConfig::INJECTION_MODULE_NAME,
					JanusConfig::INJECTION_MODULE_NAME_VALUE)
		}
		assert startupModule !== null, "No platform injection module"
		startJanusWithModule(startupModule.newInstance, agentCls, params)
	}

	override startJanusWithModule(startupModule : Module, agentCls : Class<? extends Agent>,
		params : Object*) : Kernel {
		// Prepare start
		prepareJanusStart(agentCls)
		// Get the start-up injection module
		startupModule.startWithoutAgent
		var logger = this.kernel.getLogger
		if (logger === null) {
			logger = getLogger
		}
		// TODO : Remove the message below
		logger.warning("EXPERIMENTAL VERSION")
		logger.info(MessageFormat::format(Messages::Boot_22, agentCls.name))
		val id = this.kernel.spawn(agentCls, params)
		this.bootAgentId = id
		if (id !== null) {
			System::setProperty(JanusConfig::BOOT_AGENT_ID, id.toString)
		} else {
			System::clearProperty(JanusConfig::BOOT_AGENT_ID)
		}
		return this.kernel
	}

	/** Start the Janus kernel without agent.
	 *
	 * @param the injection module.
	 * @return the kernel.
	 */
	def startWithoutAgent(startupModule : Module) : Kernel {
		assert startupModule !== null, "No platform injection module"
		val injector = Guice::createInjector(startupModule)
		this.kernel = injector.getInstance(typeof(Kernel))
		// Force the bootstrap to be this object
		SRE::bootstrap = this
		return this.kernel
	}

	override startWithoutAgent : AgentContext {
		var module = JanusConfig::getSystemPropertyAsClass(typeof(Module),
			JanusConfig::INJECTION_MODULE_NAME, JanusConfig::INJECTION_MODULE_NAME_VALUE)
		var kern = module.newInstance.startWithoutAgent
		return kern.rootContext
	}

	override startAgent(agentCls : Class<? extends Agent>, params : Object*) : UUID {
		var kern = this.kernel
		if (kern === null) {
			agentCls.startJanus(params)
			return this.bootAgentIdentifier
		}
		return kern.spawn(agentCls, params);
	}

	override startAgent(nbAgents : int, agentCls : Class<? extends Agent>, params : Object*) : Iterable<UUID> {
		var kern = this.kernel
		if (kern === null) {
			var kernel = startJanus(agentCls, params)
			var spawnedAgents = newArrayList
			spawnedAgents += this.bootAgentIdentifier
			if (nbAgents > 1) {
				spawnedAgents += kernel.spawn(nbAgents - 1, agentCls, params)
			}
			return spawnedAgents
		}
		return kern.spawn(nbAgents, agentCls, params)
	}

	
	@SuppressWarnings("discouraged_reference")
	override getExiter : Runnable {
		this.applicationExiter ?: [ System::exit(ERROR_EXIT_CODE) ]
	}

	override setExiter(exiter : Runnable) {
		this.applicationExiter = exiter
	}

	override runStandardBootProcess(args : String*) {
		try {
			var freeArgs = args.parseCommandLine
			if (JanusConfig::getSystemPropertyAsBoolean(JanusConfig::JANUS_LOGO_SHOW_NAME,
				JanusConfig::JANUS_LOGO_SHOW.booleanValue)) {
				showJanusLogo
			}

			if (freeArgs.length === 0) {
				showError(Messages::Boot_3, null)
				// Event if showError never returns, add the return statement for
				// avoiding compilation error.
				return
			}

			val agentToLaunch = freeArgs.get(0).toString
			freeArgs = Arrays::copyOfRange(freeArgs, 1, freeArgs.length, typeof(String[]))

			// Load the agent class
			val ^agent = agentToLaunch.loadAgentClass

			assert ^agent !== null
			startJanus(^agent, freeArgs)
		} catch (exception : EarlyExitException) {
			exception.runPostTreatment(this.logger)
		} catch (e : Throwable) {
			showError(MessageFormat::format(Messages::Boot_4, e.localizedMessage), e)
			// Even if showError never returns, add the return statement for
			// avoiding compilation error.
		}
	}

}
